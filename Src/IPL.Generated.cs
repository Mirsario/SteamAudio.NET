//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace SteamAudio
{
    using System.Runtime.InteropServices;
    
    public static partial class IPL
    {
        /// <summary>
        /// Status codes returned by Steam Audio API functions.
        /// </summary>
        public enum Error : int
        {
            /// <summary>
            /// The operation completed successfully.
            /// </summary>
            Success,
            
            /// <summary>
            /// An unspecified error occurred.
            /// </summary>
            Failure,
            
            /// <summary>
            /// The system ran out of memory.
            /// </summary>
            OutOfMemory,
            
            /// <summary>
            /// An error occurred while initializing an external dependency.
            /// </summary>
            Initialization,
        }
        
        /// <summary>
        /// Severity levels of log messages generated by Steam Audio.
        /// </summary>
        public enum LogLevel : int
        {
            /// <summary>
            /// A normal, informational message.
            /// </summary>
            Info,
            
            /// <summary>
            /// A warning. The operation that generated this message may not work as expected.
            /// </summary>
            Warning,
            
            /// <summary>
            /// An error. The operation that generated this message failed.
            /// </summary>
            Error,
            
            /// <summary>
            /// A detailed message intended for debugging purposes only.
            /// </summary>
            Debug,
        }
        
        /// <summary>
        /// SIMD instruction sets that Steam Audio can attempt to use.
        /// </summary>
        public enum SIMDLevel : int
        {
            /// <summary>
            /// Intel Streaming SIMD Extensions 2. Up to 4 simultaneous floating-point operations.
            /// </summary>
            Sse2,
            
            /// <summary>
            /// Intel Streaming SIMD Extensions 4.2 or older. Up to 4 simultaneous floating-point operations.
            /// </summary>
            Sse4,
            
            /// <summary>
            /// Intel Advanced Vector Extensions or older. Up to 8 simultaneous floating-point operations.
            /// </summary>
            Avx,
            
            /// <summary>
            /// Intel Advanced Vector Extensions 2 or older. Up to 8 simultaneous floating-point operations.
            /// </summary>
            Avx2,
            
            /// <summary>
            /// Intel Advanced Vector Extensions 512 or older. Up to 16 simultaneous floating-point operations.
            /// </summary>
            Avx512,
            
            /// <summary>
            /// ARM NEON. Up to 4 simultaneous floating-point operations.
            /// </summary>
            Neon = Sse2,
        }
        
        /// <summary>
        /// The type of devices to include when listing OpenCL devices.
        /// </summary>
        public enum OpenCLDeviceType : int
        {
            /// <summary>
            /// List both CPU and GPU devices.
            /// </summary>
            Any,
            
            /// <summary>
            /// Only list CPU devices.
            /// </summary>
            Cpu,
            
            /// <summary>
            /// Only list GPU devices.
            /// </summary>
            Gpu,
        }
        
        /// <summary>
        /// The types of scenes that can be created. Each scene type corresponds to a different ray tracing
        /// implementation.
        /// </summary>
        public enum SceneType : int
        {
            /// <summary>
            /// Steam Audio's built-in ray tracer. Supports multi-threading. Runs on all platforms that Steam Audio
            /// supports.
            /// </summary>
            Default,
            
            /// <summary>
            /// The Intel Embree ray tracer. Supports multi-threading. This is a highly optimized implementation, and
            /// is likely to be faster than the Phonon ray tracer. However, Embree requires Windows, Linux, or macOS,
            /// and a 32-bit x86 or 64-bit x86_64 CPU.
            /// </summary>
            Embree,
            
            /// <summary>
            /// The AMD Radeon Rays ray tracer. This is an OpenCL implementation, and can use either the CPU or any
            /// GPU that supports OpenCL 1.2 or later. If using the GPU, it is likely to be significantly faster than
            /// the Phonon ray tracer. However, with heavy real-time simulation workloads, it may impact your
            /// application's frame rate. On supported AMD GPUs, you can use the Resource Reservation feature to
            /// mitigate this issue.
            /// </summary>
            RadeonRays,
            
            /// <summary>
            /// Allows you to specify callbacks to your own ray tracer. Useful if your application already uses a 
            /// high-performance ray tracer. This option uses the least amount of memory at run-time, since it does 
            /// not have to build any ray tracing data structures of its own.
            /// </summary>
            Custom,
        }
        
        /// <summary>
        /// Supported speaker layouts.
        /// </summary>
        public enum SpeakerLayoutType : int
        {
            /// <summary>
            /// Mono.
            /// </summary>
            Mono,
            
            /// <summary>
            /// Stereo (left, right).
            /// </summary>
            Stereo,
            
            /// <summary>
            /// Front left, front right, rear left, rear right.
            /// </summary>
            Quadraphonic,
            
            /// <summary>
            /// Front left, front right, front center, LFE, rear left, rear right.
            /// </summary>
            Surround51,
            
            /// <summary>
            /// Front left, front right, front center, LFE, rear left, rear right, side left, side right.
            /// </summary>
            Surround71,
            
            /// <summary>
            /// User-defined speaker layout. See @c IPLSpeakerLayout.
            /// </summary>
            Custom,
        }
        
        /// <summary>
        /// Supported channel ordering and normalization schemes for Ambisonic audio.
        /// </summary>
        public enum AmbisonicsType : int
        {
            /// <summary>
            /// ACN channel ordering, orthonormal spherical harmonics.
            /// </summary>
            N3d,
            
            /// <summary>
            /// ACN channel ordering, semi-normalized spherical harmonics. AmbiX format.
            /// </summary>
            Sn3d,
            
            /// <summary>
            /// Furse-Malham (B-format).
            /// </summary>
            Fuma,
        }
        
        /// <summary>
        /// States that an audio effect can be left in after processing a frame of audio.
        /// </summary>
        public enum AudioEffectState : int
        {
            /// <summary>
            /// One or more samples of tail remain in the effect's internal buffers.
            /// </summary>
            Tailremaining,
            
            /// <summary>
            /// No tail remains in the effect's internal buffers.
            /// </summary>
            Tailcomplete,
        }
        
        /// <summary>
        /// The type of HRTF to use.
        /// </summary>
        public enum HRTFType : int
        {
            /// <summary>
            /// The built-in HRTF.
            /// </summary>
            Default,
            
            /// <summary>
            /// An HRTF loaded from a SOFA file.
            /// </summary>
            Sofa,
        }
        
        /// <summary>
        /// Techniques for interpolating HRTF data. This is used when rendering a point source whose position relative to
        /// the listener is not contained in the measured HRTF data.
        /// </summary>
        public enum HRTFInterpolation : int
        {
            /// <summary>
            /// Nearest-neighbor filtering, i.e., no interpolation. Selects the measurement location that is closest to 
            /// the source's actual location.
            /// </summary>
            Nearest,
            
            /// <summary>
            /// Bilinear filtering. Incurs a relatively high CPU overhead as compared to nearest-neighbor filtering, so use 
            /// this for sounds where it has a significant benefit. Typically, bilinear filtering is most useful for wide-band 
            /// noise-like sounds, such as radio static, mechanical noise, fire, etc.
            /// </summary>
            Bilinear,
        }
        
        /// <summary>
        /// Flags indicating which direct path parameters to apply.
        /// </summary>
        [Flags]
        public enum DirectEffectFlags : int
        {
            /// <summary>
            /// Apply frequency-independent distance attenuation.
            /// </summary>
            Applydistanceattenuation = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Apply frequency-dependent air absorption as a function of distance.
            /// </summary>
            Applyairabsorption = unchecked((int)1  << (int) 1),
            
            /// <summary>
            /// Apply attenuation due to source directivity pattern.
            /// </summary>
            Applydirectivity = unchecked((int)1  << (int) 2),
            
            /// <summary>
            /// Apply occlusion.
            /// </summary>
            Applyocclusion = unchecked((int)1  << (int) 3),
            
            /// <summary>
            /// Apply transmission along with occlusion.
            /// </summary>
            Applytransmission = unchecked((int)1  << (int) 4),
        }
        
        /// <summary>
        /// Modes of applying transmission effects.
        /// </summary>
        public enum TransmissionType : int
        {
            /// <summary>
            /// Transmission is frequency-independent.
            /// </summary>
            Freqindependent,
            
            /// <summary>
            /// Transmission is frequency-dependent.
            /// </summary>
            Freqdependent,
        }
        
        /// <summary>
        /// Type of reflection effect algorithm to use.
        /// </summary>
        public enum ReflectionEffectType : int
        {
            /// <summary>
            /// Multi-channel convolution reverb. Reflections reaching the listener are encoded in an Impulse Response (IR),
            /// which is a filter that records each reflection as it arrives. This algorithm renders reflections with the most
            /// detail, but may result in significant CPU usage. Using a reflection mixer with this algorithm provides a
            /// reduction in CPU usage.
            /// </summary>
            Convolution,
            
            /// <summary>
            /// Parametric (or artificial) reverb, using feedback delay networks. The reflected sound field is reduced to a few
            /// numbers that describe how reflected energy decays over time. This is then used to drive an approximate model
            /// of reverberation in an indoor space. This algorithm results in lower CPU usage, but cannot render individual
            /// echoes, especially in outdoor spaces. A reflection mixer cannot be used with this algorithm.
            /// </summary>
            Parametric,
            
            /// <summary>
            /// A hybrid of convolution and parametric reverb. The initial portion of the IR is rendered using convolution
            /// reverb, but the later part is used to estimate a parametric reverb. The point in the IR where this transition
            /// occurs can be controlled. This algorithm allows a trade-off between rendering quality and CPU usage. An
            /// reflection mixer cannot be used with this algorithm.
            /// </summary>
            Hybrid,
            
            /// <summary>
            /// Multi-channel convolution reverb, using AMD TrueAudio Next for GPU acceleration. This algorithm is similar
            /// to @c IPL_REFLECTIONEFFECTYPE_CONVOLUTION, but uses the GPU instead of the CPU for processing, allowing
            /// significantly more sources to be processed. A reflection mixer must be used with this algorithm, because
            /// the GPU will process convolution reverb at a single point in your audio processing pipeline.
            /// </summary>
            Tan,
        }
        
        /// <summary>
        /// The different algorithms for generating probes.
        /// </summary>
        public enum ProbeGenerationType : int
        {
            /// <summary>
            /// Generates a single probe at the center of the specified box.
            /// </summary>
            Centroid,
            
            /// <summary>
            /// Generates probes that are uniformly-spaced, at a fixed height above solid geometry. A probe will never be 
            /// generated above another probe unless there is a solid object between them. The goal is to model floors or 
            /// terrain, and generate probes that are a fixed height above the floor or terrain, and uniformly-spaced along 
            /// the horizontal plane. This algorithm is not suitable for scenarios where the listener may fly into a region 
            /// with no probes; if this happens, the listener will not be influenced by any of the baked data.
            /// </summary>
            Uniformfloor,
        }
        
        /// <summary>
        /// The different ways in which the source and listener positions used to generate baked data can vary as a function
        /// of probe position.
        /// </summary>
        public enum BakedDataVariation : int
        {
            /// <summary>
            /// At each probe, baked data is calculated with both the source and the listener at the probe position. This
            /// is useful for modeling traditional reverbs, which depend only on the listener's position (or only on the
            /// source's position).
            /// </summary>
            Reverb,
            
            /// <summary>
            /// At each probe, baked data is calculated with the source at some fixed position (specified separately),
            /// and the listener at the probe position. This is used for modeling reflections from a static source to any
            /// point within the probe batch.
            /// </summary>
            Staticsource,
            
            /// <summary>
            /// At each probe, baked data is calculated with the source at the probe position, and the listener at some
            /// fixed position (specified separately). This is used for modeling reflections from a moving source to a
            /// static listener.
            /// </summary>
            Staticlistener,
            
            /// <summary>
            /// Baked data is calculated for each pair of probes. For example, this is used for calculating paths between
            /// every pair of probes in a batch.
            /// </summary>
            Dynamic,
        }
        
        /// <summary>
        /// The types of baked data that can be stored in a probe batch.
        /// </summary>
        public enum BakedDataType : int
        {
            /// <summary>
            /// Reflections. The source and listener positions used to compute the reflections data stored at each probe
            /// depends on the @c IPLBakedDataVariation selected.
            /// </summary>
            Reflections,
            
            /// <summary>
            /// Pathing. The probe batch stores data about the shortest paths between any pair of probes in the batch.
            /// </summary>
            Pathing,
        }
        
        /// <summary>
        /// Flags for specifying what types of reflections data to bake.
        /// </summary>
        [Flags]
        public enum ReflectionsBakeFlags : int
        {
            /// <summary>
            /// Bake impulse responses for @c IPL_REFLECTIONEFFECTTYPE_CONVOLUTION, @c IPL_REFLECTIONEFFECTTYPE_HYBRID, or @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            Bakeconvolution = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Bake parametric reverb for @c IPL_REFLECTIONEFFECTTYPE_PARAMETRIC or @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            Bakeparametric = unchecked((int)1  << (int) 1),
        }
        
        /// <summary>
        /// Flags indicating which types of simulation should be enabled for a given @c IPLSource.
        /// </summary>
        [Flags]
        public enum SimulationFlags : int
        {
            /// <summary>
            /// Enable direct simulation. This includes distance attenuation, air absorption, directivity, occlusion, and
            /// transmission.
            /// </summary>
            Direct = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Enable reflections simulation. This includes both real-time and baked simulation.
            /// </summary>
            Reflections = unchecked((int)1  << (int) 1),
            
            /// <summary>
            /// Enable pathing simulation.
            /// </summary>
            Pathing = unchecked((int)1  << (int) 2),
        }
        
        /// <summary>
        /// Flags indicating which types of direct simulation should be enabled for a given @c IPLSource.
        /// </summary>
        [Flags]
        public enum DirectSimulationFlags : int
        {
            /// <summary>
            /// Enable distance attenuation calculations.
            /// </summary>
            Distanceattenuation = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Enable air absorption calculations.
            /// </summary>
            Airabsorption = unchecked((int)1  << (int) 1),
            
            /// <summary>
            /// Enable directivity calculations.
            /// </summary>
            Directivity = unchecked((int)1  << (int) 2),
            
            /// <summary>
            /// Enable occlusion simulation.
            /// </summary>
            Occlusion = unchecked((int)1  << (int) 3),
            
            /// <summary>
            /// Enable transmission simulation. Requires occlusion to also be enabled.
            /// </summary>
            Transmission = unchecked((int)1  << (int) 4),
        }
        
        /// <summary>
        /// The types of distance attenuation that can be used.
        /// </summary>
        public enum DistanceAttenuationModelType : int
        {
            /// <summary>
            /// The default distance attenuation model. This is an inverse distance falloff, with all sounds within 1 meter 
            /// of the listener rendered without distance attenuation.
            /// </summary>
            Default,
            
            /// <summary>
            /// An inverse distance falloff. You can configure the minimum distance, within which distance attenuation is not
            /// applied.
            /// </summary>
            InversedDistance,
            
            /// <summary>
            /// An arbitrary distance falloff function, defined by a callback function.
            /// </summary>
            Callback,
        }
        
        /// <summary>
        /// The types of air absorption that can be used.
        /// </summary>
        public enum AirAbsorptionModelType : int
        {
            /// <summary>
            /// The default air absorption model. This is an exponential falloff, with decay rates derived from physical
            /// properties of air.
            /// </summary>
            Default,
            
            /// <summary>
            /// An exponential falloff. You can configure the decay rates for each frequency band.
            /// </summary>
            Exponential,
            
            /// <summary>
            /// An arbitrary air absorption model, defined by a callback function.
            /// </summary>
            Callback,
        }
        
        /// <summary>
        /// The different algorithms for simulating occlusion.
        /// </summary>
        public enum OcclusionType : int
        {
            /// <summary>
            /// Raycast occlusion. A single ray is traced from the listener to the source. If the ray hits a solid object
            /// before it reaches the source, the source is considered occluded.
            /// </summary>
            Raycast,
            
            /// <summary>
            /// A volumetric occlusion algorithm that can model partial occlusion. The source is modeled as a sphere with
            /// a configurable radius. Multiple points are sampled within the volume of this sphere. Rays are then traced
            /// from each sample point to both the source and the listener. A sample point is considered occluded if either
            /// of these two rays is occluded. The occlusion value for the source is calculated as the fraction of
            /// sample points that are unoccluded. This algorithm allows for smoother transitions in and out of occlusion.
            /// </summary>
            Volumetric,
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLContext_t : IEquatable<_IPLContext_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLContext_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLContext_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLContext_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLContext_t left, _IPLContext_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLContext_t left, _IPLContext_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a context object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ContextSettings
        {
            /// <summary>
            /// The API version used by the caller. Context creation will fail if `phonon.dll` does not implement a
            /// compatible version of the API. Typically, this should be set to `STEAMAUDIO_VERSION`.
            /// </summary>
            public uint version;
            
            /// <summary>
            /// (Optional) If non-NULL, Steam Audio will call this function to record log messages generated by
            /// certain operations.
            /// </summary>
            public IPL.LogFunction logCallback;
            
            /// <summary>
            /// (Optional) If non-NULL, Steam Audio will call this function whenever it needs to allocate
            /// memory.
            /// </summary>
            public IPL.AllocateFunction allocateCallback;
            
            /// <summary>
            /// (Optional) If non-NULL, Steam Audio will call this function whenever it needs to free memory.
            /// </summary>
            public IPL.FreeFunction freeCallback;
            
            /// <summary>
            /// The maximum SIMD instruction set level that Steam Audio should use. Steam Audio automatically
            /// chooses the best instruction set to use based on the user's CPU, but you can prevent it from
            /// using certain newer instruction sets using this parameter. For example, with some workloads,
            /// AVX512 instructions consume enough power that the CPU clock speed will be throttled, resulting
            /// in lower performance than expected. If you observe this in your application, set this
            /// parameter to `IPL_SIMDLEVEL_AVX2` or lower.
            /// </summary>
            public IPL.SIMDLevel simdLevel;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void LogFunction(IPL.LogLevel level, [MarshalAs(UnmanagedType.LPStr)] string message);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr AllocateFunction(ulong size, ulong alignment);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FreeFunction(IntPtr memoryBlock);
        
        /// <summary>
        /// A point or vector in 3D space. Steam Audio uses a right-handed coordinate system, with the positive x-axis pointing
        /// right, the positive y-axis pointing up, and the negative z-axis pointing ahead. Position and direction data
        /// obtained from a game engine or audio engine must be properly transformed before being passed to any Steam Audio API
        /// function.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Vector3
        {
            /// <summary>
            /// The x-coordinate.
            /// </summary>
            public float x;
            
            /// <summary>
            /// The y-coordinate.
            /// </summary>
            public float y;
            
            /// <summary>
            /// The z-coordinate.
            /// </summary>
            public float z;
        }
        
        /// <summary>
        /// A 4x4 matrix used to represent an affine transform.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Matrix4x4
        {
            /// <summary>
            /// Matrix elements, in row-major order.
            /// </summary>
            public fixed float elements[16];
        }
        
        /// <summary>
        /// An axis-aligned box. Axis-aligned boxes are used to specify a volume of 3D space.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Box
        {
            /// <summary>
            /// The minimum coordinates of any vertex.
            /// </summary>
            public IPL.Vector3 minCoordinates;
            
            /// <summary>
            /// The maximum coordinates of any vertex.
            /// </summary>
            public IPL.Vector3 maxCoordinates;
        }
        
        /// <summary>
        /// A sphere. Spheres are used to define a region of influence around a point.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Sphere
        {
            /// <summary>
            /// The center.
            /// </summary>
            public IPL.Vector3 center;
            
            /// <summary>
            /// The radius.
            /// </summary>
            public float radius;
        }
        
        /// <summary>
        /// A 3D coordinate system, expressed relative to a canonical coordinate system.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct CoordinateSpace3
        {
            /// <summary>
            /// Unit vector pointing to the right (local +x axis).
            /// </summary>
            public IPL.Vector3 right;
            
            /// <summary>
            /// Unit vector pointing upwards (local +y axis).
            /// </summary>
            public IPL.Vector3 up;
            
            /// <summary>
            /// Unit vector pointing forwards (local -z axis).
            /// </summary>
            public IPL.Vector3 ahead;
            
            /// <summary>
            /// The origin, relative to the canonical coordinate system.
            /// </summary>
            public IPL.Vector3 origin;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLSerializedObject_t : IEquatable<_IPLSerializedObject_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLSerializedObject_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLSerializedObject_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLSerializedObject_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLSerializedObject_t left, _IPLSerializedObject_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLSerializedObject_t left, _IPLSerializedObject_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a serialized object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SerializedObjectSettings
        {
            /// <summary>
            /// If non-NULL, the serialized object will contain the data in this buffer. If NULL,
            /// the serialized object will start out empty.
            /// </summary>
            public IntPtr data;
            
            /// <summary>
            /// The number of bytes in the buffer pointed to by @c data. Set to 0 if @c data is 
            /// NULL.
            /// </summary>
            public ulong size;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLEmbreeDevice_t : IEquatable<_IPLEmbreeDevice_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLEmbreeDevice_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLEmbreeDevice_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLEmbreeDevice_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLEmbreeDevice_t left, _IPLEmbreeDevice_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLEmbreeDevice_t left, _IPLEmbreeDevice_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct EmbreeDeviceSettings
        {
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLOpenCLDeviceList_t : IEquatable<_IPLOpenCLDeviceList_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLOpenCLDeviceList_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLOpenCLDeviceList_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLOpenCLDeviceList_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLOpenCLDeviceList_t left, _IPLOpenCLDeviceList_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLOpenCLDeviceList_t left, _IPLOpenCLDeviceList_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLOpenCLDevice_t : IEquatable<_IPLOpenCLDevice_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLOpenCLDevice_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLOpenCLDevice_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLOpenCLDevice_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLOpenCLDevice_t left, _IPLOpenCLDevice_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLOpenCLDevice_t left, _IPLOpenCLDevice_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Specifies requirements that an OpenCL device must meet in order to be considered when listing
        /// OpenCL devices.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct OpenCLDeviceSettings
        {
            /// <summary>
            /// The type of device. Set to @c IPL_OPENCLDEVICETYPE_ANY to consider all available devices.
            /// </summary>
            public IPL.OpenCLDeviceType type;
            
            /// <summary>
            /// The number of GPU compute units (CUs) that should be reserved for use by Steam Audio. If set to a
            /// non-zero value, then a GPU will be included in the device list only if it can reserve at least
            /// this many CUs. Set to 0 to indicate that Steam Audio can use the entire GPU, in which case all
            /// available GPUs will be considered.
            /// </summary>
            /// <remarks>
            /// Ignored if @c type is @c IPL_OPENCLDEVICETYPE_CPU.
            /// </remarks>
            public int numCUsToReserve;
            
            /// <summary>
            /// The fraction of reserved CUs that should be used for impulse response (IR) update. IR update
            /// includes: a) ray tracing using Radeon Rays to simulate sound propagation, and/or b) pre-transformation
            /// of IRs for convolution using TrueAudio Next. Steam Audio will only list GPU devices that are able
            /// to subdivide the reserved CUs as per this value. The value must be between 0 and 1.
            /// </summary>
            /// <remarks>
            /// For example, if @c numCUsToReserve is @c 8, and @c fractionCUsForIRUpdate is @c 0.5f, then 4 CUs
            /// will be used for IR update and 4 CUs will be used for convolution. Below are typical scenarios:-   Using only TrueAudio Next. Set @c fractionCUsForIRUpdate to @c 0.5f. This ensures that reserved
            /// CUs are available for IR update as well as convolution.-   Using TrueAudio Next and Radeon Rays for real-time simulation and rendering. Choosing
            /// @c fractionCUsForIRUpdate may require some experimentation to utilize reserved CUs optimally. You
            /// can start by setting @c fractionCUsForIRUpdate to @c 0.5f. However, if IR calculation has high
            /// latency with these settings, increase @c fractionCUsForIRUpdate to use more CUs for ray tracing.-   Using only Radeon Rays. Set @c fractionCUsForIRUpdate to @c 1, to make sure all the reserved CUs
            /// are used for ray tracing. If using Steam Audio for preprocessing (e.g. baking reverb), then
            /// consider setting @c numCUsToReserve to @c 0 to use the entire GPU for accelerated ray tracing.Ignored if @c type is @c IPL_OPENCLDEVICETYPE_CPU or @c numCUsToReserve is @c 0.
            /// </remarks>
            public float fractionCUsForIRUpdate;
            
            /// <summary>
            /// If @c IPL_TRUE, then the GPU device must support TrueAudio Next. It is not necessary to set this
            /// to @c IPL_TRUE if @c numCUsToReserve or @c fractionCUsForIRUpdate are set to non-zero values.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool requiresTAN;
        }
        
        /// <summary>
        /// Describes the properties of an OpenCL device. This information can be used to select the most suitable
        /// device for your application.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct OpenCLDeviceDesc
        {
            /// <summary>
            /// The OpenCL platform id. Can be cast to @c cl_platform_id.
            /// </summary>
            public IntPtr platform;
            
            /// <summary>
            /// The OpenCL platform name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string platformName;
            
            /// <summary>
            /// The OpenCL platform vendor's name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string platformVendor;
            
            /// <summary>
            /// The OpenCL platform version.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string platformVersion;
            
            /// <summary>
            /// The OpenCL device id. Can be cast to @c cl_device_id.
            /// </summary>
            public IntPtr device;
            
            /// <summary>
            /// The OpenCL device name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string deviceName;
            
            /// <summary>
            /// The OpenCL device vendor's name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string deviceVendor;
            
            /// <summary>
            /// The OpenCL device version.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string deviceVersion;
            
            /// <summary>
            /// The type of OpenCL device.
            /// </summary>
            public IPL.OpenCLDeviceType type;
            
            /// <summary>
            /// The number of CUs reserved for convolution. May be @c 0 if CU reservation is not supported.
            /// </summary>
            public int numConvolutionCUs;
            
            /// <summary>
            /// The number of CUs reserved for IR update. May be @c 0 if CU reservation is not supported.
            /// </summary>
            public int numIRUpdateCUs;
            
            /// <summary>
            /// The CU reservation granularity. CUs can only be reserved on this device in multiples of this number.
            /// </summary>
            public int granularity;
            
            /// <summary>
            /// A relative performance score of a single CU of this device. Only applicable to supported AMD GPUs.
            /// </summary>
            public float perfScore;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLRadeonRaysDevice_t : IEquatable<_IPLRadeonRaysDevice_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLRadeonRaysDevice_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLRadeonRaysDevice_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLRadeonRaysDevice_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLRadeonRaysDevice_t left, _IPLRadeonRaysDevice_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLRadeonRaysDevice_t left, _IPLRadeonRaysDevice_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct RadeonRaysDeviceSettings
        {
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLTrueAudioNextDevice_t : IEquatable<_IPLTrueAudioNextDevice_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLTrueAudioNextDevice_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLTrueAudioNextDevice_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLTrueAudioNextDevice_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLTrueAudioNextDevice_t left, _IPLTrueAudioNextDevice_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLTrueAudioNextDevice_t left, _IPLTrueAudioNextDevice_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a TrueAudio Next device.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct TrueAudioNextDeviceSettings
        {
            /// <summary>
            /// The number of samples in an audio frame.
            /// </summary>
            public int frameSize;
            
            /// <summary>
            /// The number of samples in the impulse responses that will be used for convolution.
            /// </summary>
            public int irSize;
            
            /// <summary>
            /// The Ambisonic order of the impulse responses that will be used for convolution.
            /// </summary>
            public int order;
            
            /// <summary>
            /// The maximum number of sources that will use TrueAudio Next for convolution.
            /// </summary>
            public int maxSources;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLScene_t : IEquatable<_IPLScene_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLScene_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLScene_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLScene_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLScene_t left, _IPLScene_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLScene_t left, _IPLScene_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLStaticMesh_t : IEquatable<_IPLStaticMesh_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLStaticMesh_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLStaticMesh_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLStaticMesh_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLStaticMesh_t left, _IPLStaticMesh_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLStaticMesh_t left, _IPLStaticMesh_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLInstancedMesh_t : IEquatable<_IPLInstancedMesh_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLInstancedMesh_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLInstancedMesh_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLInstancedMesh_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLInstancedMesh_t left, _IPLInstancedMesh_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLInstancedMesh_t left, _IPLInstancedMesh_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A triangle in 3D space.
        /// </summary>
        /// <remarks>
        /// Triangles are specified by their three vertices, which are in turn specified using indices into a 
        /// vertex array.Steam Audio uses a counter-clockwise winding order. This means that when looking at the triangle such that the 
        /// normal is pointing towards you, the vertices are specified in counter-clockwise order.Each triangle must be specified using three vertices; triangle strip or fan representations are 
        /// not supported.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Triangle
        {
            /// <summary>
            /// Indices of the three vertices of this triangle.
            /// </summary>
            public fixed int indices[3];
        }
        
        /// <summary>
        /// The acoustic properties of a surface.
        /// </summary>
        /// <remarks>
        /// You can specify the acoustic material properties of each triangle, although typically many triangles will 
        /// share a common material.The acoustic material properties are specified for three frequency bands with center frequencies of 
        /// 400 Hz, 2.5 KHz, and 15 KHz.Below are the acoustic material properties for a few standard materials.```cpp
        /// {"generic",{0.10f,0.20f,0.30f,0.05f,0.100f,0.050f,0.030f}}
        /// {"brick",{0.03f,0.04f,0.07f,0.05f,0.015f,0.015f,0.015f}}
        /// {"concrete",{0.05f,0.07f,0.08f,0.05f,0.015f,0.002f,0.001f}}
        /// {"ceramic",{0.01f,0.02f,0.02f,0.05f,0.060f,0.044f,0.011f}}
        /// {"gravel",{0.60f,0.70f,0.80f,0.05f,0.031f,0.012f,0.008f}},
        /// {"carpet",{0.24f,0.69f,0.73f,0.05f,0.020f,0.005f,0.003f}}
        /// {"glass",{0.06f,0.03f,0.02f,0.05f,0.060f,0.044f,0.011f}}
        /// {"plaster",{0.12f,0.06f,0.04f,0.05f,0.056f,0.056f,0.004f}}
        /// {"wood",{0.11f,0.07f,0.06f,0.05f,0.070f,0.014f,0.005f}}
        /// {"metal",{0.20f,0.07f,0.06f,0.05f,0.200f,0.025f,0.010f}}
        /// {"rock",{0.13f,0.20f,0.24f,0.05f,0.015f,0.002f,0.001f}}
        /// ```
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Material
        {
            /// <summary>
            /// Fraction of sound energy absorbed at low, middle, high frequencies. Between 0.0 and 1.0.
            /// </summary>
            public fixed float absorption[3];
            
            /// <summary>
            /// Fraction of sound energy scattered in a random direction on reflection. Between 0.0 (pure specular) and 1.0 
            /// (pure diffuse).
            /// </summary>
            public float scattering;
            
            /// <summary>
            /// Fraction of sound energy transmitted through at low, middle, high frequencies. Between 0.0 and 1.0. 
            /// Only used for direct occlusion calculations.
            /// </summary>
            public fixed float transmission[3];
        }
        
        /// <summary>
        /// A ray in 3D space.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Ray
        {
            /// <summary>
            /// Origin of the ray.
            /// </summary>
            public IPL.Vector3 origin;
            
            /// <summary>
            /// Unit vector direction of the ray.
            /// </summary>
            public IPL.Vector3 direction;
        }
        
        /// <summary>
        /// Information about a ray's intersection with 3D geometry.
        /// </summary>
        /// <remarks>
        /// This information should be provided by ray tracer callbacks when using @c IPL_SCENETYPE_CUSTOM. Not all
        /// fields are required.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Hit
        {
            /// <summary>
            /// Distance along the ray from origin to hit point. Set to @c INFINITY if nothing was hit.
            /// </summary>
            public float distance;
            
            /// <summary>
            /// (Optional) Index of the primitive hit by the ray. @c -1 if not provided.
            /// </summary>
            public int triangleIndex;
            
            /// <summary>
            /// (Optional) Index of the scene object hit by the ray. @c -1 if not provided.
            /// </summary>
            public int objectIndex;
            
            /// <summary>
            /// (Optional) Index of the material associated with the primitive hit by the ray. @c -1 if not provided.
            /// </summary>
            public int materialIndex;
            
            /// <summary>
            /// Unit length surface normal at the hit point. Ignored if nothing was hit.
            /// </summary>
            public IPL.Vector3 normal;
            
            /// <summary>
            /// Pointer to the material at the hit point. Ignored if nothing was hit.
            /// </summary>
            public IntPtr material;
        }
        
        /// <summary>
        /// Settings used to create a scene.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SceneSettings
        {
            /// <summary>
            /// Type of scene to create.
            /// </summary>
            public IPL.SceneType type;
            
            /// <summary>
            /// Callback for finding the closest hit along a ray. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.ClosestHitCallback closestHitCallback;
            
            /// <summary>
            /// Callback for finding whether a ray hits anything. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.AnyHitCallback anyHitCallback;
            
            /// <summary>
            /// Callback for finding the closest hit along a batch of rays. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.BatchedClosestHitCallback batchedClosestHitCallback;
            
            /// <summary>
            /// Callback for finding whether a batch of rays hits anything. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.BatchedAnyHitCallback batchedAnyHitCallback;
            
            /// <summary>
            /// Arbitrary user-provided data for use by ray tracing callbacks. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IntPtr userData;
            
            /// <summary>
            /// Handle to an Embree device. Only for @c IPL_SCENETYPE_EMBREE.
            /// </summary>
            public IPL._IPLEmbreeDevice_t embreeDevice;
            
            /// <summary>
            /// Handle to a Radeon Rays device. Only for @c IPL_SCENETYPE_RADEONRAYS.
            /// </summary>
            public IPL._IPLRadeonRaysDevice_t radeonRaysDevice;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void ClosestHitCallback(in IPL.Ray ray, float minDistance, float maxDistance, ref IPL.Hit hit, IntPtr userData);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void AnyHitCallback(in IPL.Ray ray, float minDistance, float maxDistance, ref byte occluded, IntPtr userData);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void BatchedClosestHitCallback(int numRays, in IPL.Ray rays, ref float minDistances, ref float maxDistances, ref IPL.Hit hits, IntPtr userData);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void BatchedAnyHitCallback(int numRays, in IPL.Ray rays, ref float minDistances, ref float maxDistances, ref byte occluded, IntPtr userData);
        
        /// <summary>
        /// Settings used to create a static mesh.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct StaticMeshSettings
        {
            /// <summary>
            /// Number of vertices.
            /// </summary>
            public int numVertices;
            
            /// <summary>
            /// Number of triangles.
            /// </summary>
            public int numTriangles;
            
            /// <summary>
            /// Number of materials.
            /// </summary>
            public int numMaterials;
            
            /// <summary>
            /// Array containing vertices.
            /// </summary>
            public IntPtr vertices;
            
            /// <summary>
            /// Array containing (indexed) triangles.
            /// </summary>
            public IntPtr triangles;
            
            /// <summary>
            /// Array containing, for each triangle, the index of the associated material.
            /// </summary>
            public IntPtr materialIndices;
            
            /// <summary>
            /// Array of materials.
            /// </summary>
            public IntPtr materials;
        }
        
        /// <summary>
        /// Settings used to create an instanced mesh.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct InstancedMeshSettings
        {
            /// <summary>
            /// Handle to the scene to be instantiated.
            /// </summary>
            public IPL._IPLScene_t subScene;
            
            /// <summary>
            /// Local-to-world transform that places the instance within the parent scene.
            /// </summary>
            public IPL.Matrix4x4 transform;
        }
        
        /// <summary>
        /// Describes a standard or custom speaker layout.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SpeakerLayout
        {
            /// <summary>
            /// See @c IPLSpeakerLayoutType.
            /// </summary>
            public IPL.SpeakerLayoutType type;
            
            /// <summary>
            /// Number of speakers. Only for IPL_SPEAKERLAYOUTTYPE_CUSTOM.
            /// </summary>
            public int numSpeakers;
            
            /// <summary>
            /// Array of unit-length directions for each speaker. Only for IPL_SPEAKERLAYOUTTYPE_CUSTOM.
            /// </summary>
            public IntPtr speakers;
        }
        
        /// <summary>
        /// Global settings for audio signal processing.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AudioSettings
        {
            /// <summary>
            /// Sampling rate, in Hz.
            /// </summary>
            public int samplingRate;
            
            /// <summary>
            /// Frame size, in samples. Independent of number of channels.
            /// </summary>
            public int frameSize;
        }
        
        /// <summary>
        /// Describes an audio buffer. All audio buffers passed to Steam Audio must be deinterleaved.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AudioBuffer
        {
            /// <summary>
            /// Number of channels.
            /// </summary>
            public int numChannels;
            
            /// <summary>
            /// Number of samples per channel.
            /// </summary>
            public int numSamples;
            
            /// <summary>
            /// Array of pointers to sample data for each channel. Allocation of sample data is up to the user.
            /// </summary>
            public IntPtr data;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLHRTF_t : IEquatable<_IPLHRTF_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLHRTF_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLHRTF_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLHRTF_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLHRTF_t left, _IPLHRTF_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLHRTF_t left, _IPLHRTF_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an HRTF object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct HRTFSettings
        {
            /// <summary>
            /// The type of HRTF to create.
            /// </summary>
            public IPL.HRTFType type;
            
            /// <summary>
            /// SOFA file from which to load HRTF data. Only for @c IPL_HRTFTYPE_SOFA.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string sofaFileName;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLPanningEffect_t : IEquatable<_IPLPanningEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLPanningEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLPanningEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLPanningEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLPanningEffect_t left, _IPLPanningEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLPanningEffect_t left, _IPLPanningEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a panning effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PanningEffectSettings
        {
            /// <summary>
            /// The speaker layout to pan input audio to.
            /// </summary>
            public IPL.SpeakerLayout speakerLayout;
        }
        
        /// <summary>
        /// Parameters for applying a panning effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PanningEffectParams
        {
            /// <summary>
            /// Unit vector pointing from the listener towards the source.
            /// </summary>
            public IPL.Vector3 direction;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLBinauralEffect_t : IEquatable<_IPLBinauralEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLBinauralEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLBinauralEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLBinauralEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLBinauralEffect_t left, _IPLBinauralEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLBinauralEffect_t left, _IPLBinauralEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a binaural effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct BinauralEffectSettings
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
        }
        
        /// <summary>
        /// Parameters for applying a binaural effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct BinauralEffectParams
        {
            /// <summary>
            /// Unit vector pointing from the listener towards the source.
            /// </summary>
            public IPL.Vector3 direction;
            
            /// <summary>
            /// The interpolation technique to use.
            /// </summary>
            public IPL.HRTFInterpolation interpolation;
            
            /// <summary>
            /// Amount to blend input audio with spatialized audio. When set to 0, output audio is not spatialized at all 
            /// and is close to input audio. If set to 1, output audio is fully spatialized.
            /// </summary>
            public float spatialBlend;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLVirtualSurroundEffect_t : IEquatable<_IPLVirtualSurroundEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLVirtualSurroundEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLVirtualSurroundEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLVirtualSurroundEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLVirtualSurroundEffect_t left, _IPLVirtualSurroundEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLVirtualSurroundEffect_t left, _IPLVirtualSurroundEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a virtual surround effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct VirtualSurroundEffectSettings
        {
            /// <summary>
            /// The speaker layout that will be used by input audio buffers.
            /// </summary>
            public IPL.SpeakerLayout speakerLayout;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
        }
        
        /// <summary>
        /// Parameters for applying a virtual surround effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct VirtualSurroundEffectParams
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLAmbisonicsEncodeEffect_t : IEquatable<_IPLAmbisonicsEncodeEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLAmbisonicsEncodeEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLAmbisonicsEncodeEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLAmbisonicsEncodeEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLAmbisonicsEncodeEffect_t left, _IPLAmbisonicsEncodeEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLAmbisonicsEncodeEffect_t left, _IPLAmbisonicsEncodeEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics encode effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsEncodeEffectSettings
        {
            /// <summary>
            /// Maximum Ambisonics order to encode audio buffers to.
            /// </summary>
            public int maxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics encode effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsEncodeEffectParams
        {
            /// <summary>
            /// Unit vector pointing from the listener towards the source.
            /// </summary>
            public IPL.Vector3 direction;
            
            /// <summary>
            /// Ambisonic order of the output buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will generate fewer output channels, reducing CPU usage.
            /// </summary>
            public int order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLAmbisonicsPanningEffect_t : IEquatable<_IPLAmbisonicsPanningEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLAmbisonicsPanningEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLAmbisonicsPanningEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLAmbisonicsPanningEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLAmbisonicsPanningEffect_t left, _IPLAmbisonicsPanningEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLAmbisonicsPanningEffect_t left, _IPLAmbisonicsPanningEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics panning effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsPanningEffectSettings
        {
            /// <summary>
            /// The speaker layout that will be used by output audio buffers.
            /// </summary>
            public IPL.SpeakerLayout speakerLayout;
            
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int maxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics panning effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsPanningEffectParams
        {
            /// <summary>
            /// Ambisonic order of the input buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will process fewer input channels, reducing CPU usage.
            /// </summary>
            public int order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLAmbisonicsBinauralEffect_t : IEquatable<_IPLAmbisonicsBinauralEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLAmbisonicsBinauralEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLAmbisonicsBinauralEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLAmbisonicsBinauralEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLAmbisonicsBinauralEffect_t left, _IPLAmbisonicsBinauralEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLAmbisonicsBinauralEffect_t left, _IPLAmbisonicsBinauralEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics binaural effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsBinauralEffectSettings
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
            
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int maxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics binaural effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsBinauralEffectParams
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
            
            /// <summary>
            /// Ambisonic order of the input buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will process fewer input channels, reducing CPU usage.
            /// </summary>
            public int order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLAmbisonicsRotationEffect_t : IEquatable<_IPLAmbisonicsRotationEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLAmbisonicsRotationEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLAmbisonicsRotationEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLAmbisonicsRotationEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLAmbisonicsRotationEffect_t left, _IPLAmbisonicsRotationEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLAmbisonicsRotationEffect_t left, _IPLAmbisonicsRotationEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics rotation effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsRotationEffectSettings
        {
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int maxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics rotation effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsRotationEffectParams
        {
            /// <summary>
            /// The orientation of the listener.
            /// </summary>
            public IPL.CoordinateSpace3 orientation;
            
            /// <summary>
            /// Ambisonic order of the input and output buffers. May be less than the @c maxOrder specified when creating the 
            /// effect, in which case the effect will process fewer channels, reducing CPU usage.
            /// </summary>
            public int order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLAmbisonicsDecodeEffect_t : IEquatable<_IPLAmbisonicsDecodeEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLAmbisonicsDecodeEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLAmbisonicsDecodeEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLAmbisonicsDecodeEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLAmbisonicsDecodeEffect_t left, _IPLAmbisonicsDecodeEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLAmbisonicsDecodeEffect_t left, _IPLAmbisonicsDecodeEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics decode effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsDecodeEffectSettings
        {
            /// <summary>
            /// The speaker layout that will be used by output audio buffers.
            /// </summary>
            public IPL.SpeakerLayout speakerLayout;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
            
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int maxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics decode effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsDecodeEffectParams
        {
            /// <summary>
            /// Ambisonic order of the input buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will process fewer input channels, reducing CPU usage.
            /// </summary>
            public int order;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL._IPLHRTF_t hrtf;
            
            /// <summary>
            /// The orientation of the listener.
            /// </summary>
            public IPL.CoordinateSpace3 orientation;
            
            /// <summary>
            /// Whether to use binaural rendering or panning.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool binaural;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLDirectEffect_t : IEquatable<_IPLDirectEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLDirectEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLDirectEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLDirectEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLDirectEffect_t left, _IPLDirectEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLDirectEffect_t left, _IPLDirectEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a direct effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct DirectEffectSettings
        {
            /// <summary>
            /// Number of channels that will be used by input and output buffers.
            /// </summary>
            public int numChannels;
        }
        
        /// <summary>
        /// Parameters for applying a direct effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct DirectEffectParams
        {
            /// <summary>
            /// Flags indicating which direct path effects to apply.
            /// </summary>
            public IPL.DirectEffectFlags flags;
            
            /// <summary>
            /// Mode of applying transmission effect, if @c IPL_DIRECTEFFECTFLAGS_APPLYTRANSMISSION is enabled.
            /// </summary>
            public IPL.TransmissionType transmissionType;
            
            /// <summary>
            /// Value of distance attenuation, between 0 and 1.
            /// </summary>
            public float distanceAttenuation;
            
            /// <summary>
            /// 3-band EQ coefficients for air absorption, each between 0 and 1.
            /// </summary>
            public fixed float airAbsorption[3];
            
            /// <summary>
            /// Value of directivity term, between 0 and 1.
            /// </summary>
            public float directivity;
            
            /// <summary>
            /// Value of occlusion factor, between 0 and 1.
            /// </summary>
            public float occlusion;
            
            /// <summary>
            /// 3-band EQ coefficients for transmission, each between 0 and 1.
            /// </summary>
            public fixed float transmission[3];
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLReflectionEffectIR_t : IEquatable<_IPLReflectionEffectIR_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLReflectionEffectIR_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLReflectionEffectIR_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLReflectionEffectIR_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLReflectionEffectIR_t left, _IPLReflectionEffectIR_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLReflectionEffectIR_t left, _IPLReflectionEffectIR_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLReflectionEffect_t : IEquatable<_IPLReflectionEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLReflectionEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLReflectionEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLReflectionEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLReflectionEffect_t left, _IPLReflectionEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLReflectionEffect_t left, _IPLReflectionEffect_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLReflectionMixer_t : IEquatable<_IPLReflectionMixer_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLReflectionMixer_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLReflectionMixer_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLReflectionMixer_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLReflectionMixer_t left, _IPLReflectionMixer_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLReflectionMixer_t left, _IPLReflectionMixer_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a reflection effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ReflectionEffectSettings
        {
            /// <summary>
            /// Type of reflection effect algorithm to use.
            /// </summary>
            public IPL.ReflectionEffectType type;
            
            /// <summary>
            /// Number of samples per channel in the IR.
            /// </summary>
            public int irSize;
            
            /// <summary>
            /// Number of channels in the IR.
            /// </summary>
            public int numChannels;
        }
        
        /// <summary>
        /// Parameters for applying a reflection effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct ReflectionEffectParams
        {
            /// <summary>
            /// Type of reflection effect algorithm to use.
            /// </summary>
            public IPL.ReflectionEffectType type;
            
            /// <summary>
            /// The impulse response. For @c IPL_REFLECTIONEFFECTTYPE_CONVOLUTION or @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public IPL._IPLReflectionEffectIR_t ir;
            
            /// <summary>
            /// 3-band reverb decay times (RT60). For @c IPL_REFLECTIONEFFECTTYPE_PARAMETRIC or 
            /// @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public fixed float reverbTimes[3];
            
            /// <summary>
            /// 3-band EQ coefficients applied to the parametric part to ensure smooth transition. 
            /// For @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public fixed float eq[3];
            
            /// <summary>
            /// Samples after which parametric part starts. For @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public int delay;
            
            /// <summary>
            /// Number of IR channels to process. May be less than the number of channels specified when creating the effect,
            /// in which case CPU usage will be reduced.
            /// </summary>
            public int numChannels;
            
            /// <summary>
            /// Number of IR samples per channel to process. May be less than the number of samples specified when creating
            /// the effect, in which case CPU usage will be reduced.
            /// </summary>
            public int irSize;
            
            /// <summary>
            /// The TrueAudio Next device to use for convolution processing. For @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public IPL._IPLTrueAudioNextDevice_t tanDevice;
            
            /// <summary>
            /// The TrueAudio Next slot index to use for convolution processing. The slot identifies the IR to use. For
            /// @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public int tanSlot;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLPathEffect_t : IEquatable<_IPLPathEffect_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLPathEffect_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLPathEffect_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLPathEffect_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLPathEffect_t left, _IPLPathEffect_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLPathEffect_t left, _IPLPathEffect_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a path effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PathEffectSettings
        {
            /// <summary>
            /// The maximum Ambisonics order that will be used by output audio buffers.
            /// </summary>
            public int maxOrder;
        }
        
        /// <summary>
        /// Parameters for applying a path effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct PathEffectParams
        {
            /// <summary>
            /// 3-band EQ coefficients for modeling frequency-dependent attenuation caused by paths bending around
            /// obstacles.
            /// </summary>
            public fixed float eqCoeffs[3];
            
            /// <summary>
            /// Ambisonic coefficients for modeling the directional distribution of sound reaching the listener.
            /// The coefficients are specified in world-space, and must be rotated to match the listener's orientation
            /// separately.
            /// </summary>
            public IntPtr shCoeffs;
            
            /// <summary>
            /// Ambisonic order of the output buffer. May be less than the maximum order specified when creating the effect,
            /// in which case higher-order @c shCoeffs will be ignored, and CPU usage will be reduced.
            /// </summary>
            public int order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLProbeArray_t : IEquatable<_IPLProbeArray_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLProbeArray_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLProbeArray_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLProbeArray_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLProbeArray_t left, _IPLProbeArray_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLProbeArray_t left, _IPLProbeArray_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLProbeBatch_t : IEquatable<_IPLProbeBatch_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLProbeBatch_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLProbeBatch_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLProbeBatch_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLProbeBatch_t left, _IPLProbeBatch_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLProbeBatch_t left, _IPLProbeBatch_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to generate probes.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ProbeGenerationParams
        {
            /// <summary>
            /// The algorithm to use for generating probes.
            /// </summary>
            public IPL.ProbeGenerationType type;
            
            /// <summary>
            /// Spacing (in meters) between two neighboring probes. Only for @c IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR.
            /// </summary>
            public float spacing;
            
            /// <summary>
            /// Height (in meters) above the floor at which probes will be generated. Only for
            /// @c IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR.
            /// </summary>
            public float height;
            
            /// <summary>
            /// A transformation matrix that transforms an axis-aligned unit cube, with minimum and maximum vertices
            /// at (0, 0, 0) and (1, 1, 1), into a parallelopiped volume. Probes will be generated within this
            /// volume.
            /// </summary>
            public IPL.Matrix4x4 transform;
        }
        
        /// <summary>
        /// Identifies a "layer" of data stored in a probe batch. Each probe batch may store multiple layers of data,
        /// such as reverb, static source reflections, or pathing. Each layer can be accessed using an identifier.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct BakedDataIdentifier
        {
            /// <summary>
            /// The type of data stored.
            /// </summary>
            public IPL.BakedDataType type;
            
            /// <summary>
            /// The way in which source and listener positions depend on probe position.
            /// </summary>
            public IPL.BakedDataVariation variation;
            
            /// <summary>
            /// The static source (for @c IPL_BAKEDDATAVARIATION_STATICSOURCE) or static listener (for
            /// @c IPL_BAKEDDATAVARIATION_STATICLISTENER) used to generate baked data. Baked data is only stored for
            /// probes that lie within the radius of this sphere.
            /// </summary>
            public IPL.Sphere endpointInfluence;
        }
        
        /// <summary>
        /// Parameters used to control how reflections data is baked.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ReflectionsBakeParams
        {
            /// <summary>
            /// The scene in which the probes exist.
            /// </summary>
            public IPL._IPLScene_t scene;
            
            /// <summary>
            /// A probe batch containing the probes at which reflections data should be baked.
            /// </summary>
            public IPL._IPLProbeBatch_t probeBatch;
            
            /// <summary>
            /// The type of scene being used.
            /// </summary>
            public IPL.SceneType sceneType;
            
            /// <summary>
            /// An identifier for the data layer that should be baked. The identifier determines what data is simulated and
            /// stored at each probe. If the probe batch already contains data with this identifier, it will be overwritten.
            /// </summary>
            public IPL.BakedDataIdentifier identifier;
            
            /// <summary>
            /// The types of data to save for each probe.
            /// </summary>
            public IPL.ReflectionsBakeFlags bakeFlags;
            
            /// <summary>
            /// The number of rays to trace from each listener position when baking. Increasing this number results in
            /// improved accuracy, at the cost of increased bake times.
            /// </summary>
            public int numRays;
            
            /// <summary>
            /// The number of directions to consider when generating diffusely-reflected rays when baking. Increasing
            /// this number results in slightly improved accuracy of diffuse reflections.
            /// </summary>
            public int numDiffuseSamples;
            
            /// <summary>
            /// The number of times each ray is reflected off of solid geometry. Increasing this number results in
            /// longer reverb tails and improved accuracy, at the cost of increased bake times.
            /// </summary>
            public int numBounces;
            
            /// <summary>
            /// The length (in seconds) of the impulse responses to simulate. Increasing this number allows the baked
            /// data to represent longer reverb tails (and hence larger spaces), at the cost of increased memory
            /// usage while baking.
            /// </summary>
            public float simulatedDuration;
            
            /// <summary>
            /// The length (in seconds) of the impulse responses to save at each probe. Increasing this number allows
            /// the baked data to represent longer reverb tails (and hence larger spaces), at the cost of increased
            /// disk space usage and memory usage at run-time.
            /// </summary>
            /// <remarks>
            /// It may be useful to set @c savedDuration to be less than @c simulatedDuration, especially if you plan
            /// to use hybrid reverb for rendering baked reflections. This way, the parametric reverb data is
            /// estimated using a longer IR, resulting in more accurate estimation, but only the early part of the IR
            /// can be saved for subsequent rendering.
            /// </remarks>
            public float savedDuration;
            
            /// <summary>
            /// Ambisonic order of the baked IRs.
            /// </summary>
            public int order;
            
            /// <summary>
            /// Number of threads to use for baking.
            /// </summary>
            public int numThreads;
            
            /// <summary>
            /// If using custom ray tracer callbacks, this the number of rays that will be passed to the callbacks
            /// every time rays need to be traced.
            /// </summary>
            public int rayBatchSize;
            
            /// <summary>
            /// When calculating how much sound energy reaches a surface directly from a source, any source that is
            /// closer than @c irradianceMinDistance to the surface is assumed to be at a distance of
            /// @c irradianceMinDistance, for the purposes of energy calculations.
            /// </summary>
            public float irradianceMinDistance;
            
            /// <summary>
            /// If using Radeon Rays, this is the number of probes for which data is baked simultaneously.
            /// </summary>
            public int bakeBatchSize;
            
            /// <summary>
            /// The OpenCL device, if using Radeon Rays.
            /// </summary>
            public IPL._IPLOpenCLDevice_t openCLDevice;
            
            /// <summary>
            /// The Radeon Rays device, if using Radeon Rays.
            /// </summary>
            public IPL._IPLRadeonRaysDevice_t radeonRaysDevice;
        }
        
        /// <summary>
        /// Parameters used to control how pathing data is baked.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PathBakeParams
        {
            /// <summary>
            /// The scene in which the probes exist.
            /// </summary>
            public IPL._IPLScene_t scene;
            
            /// <summary>
            /// A probe batch containing the probes for which pathing data should be baked.
            /// </summary>
            public IPL._IPLProbeBatch_t probeBatch;
            
            /// <summary>
            /// An identifier for the data layer that should be baked. The identifier determines what data is simulated and
            /// stored at each probe. If the probe batch already contains data with this identifier, it will be overwritten.
            /// </summary>
            public IPL.BakedDataIdentifier identifier;
            
            /// <summary>
            /// Number of point samples to use around each probe when testing whether one probe can see another. To
            /// determine if two probes are mutually visible, numSamples * numSamples rays are traced, from each
            /// point sample of the first probe, to every other point sample of the second probe.
            /// </summary>
            public int numSamples;
            
            /// <summary>
            /// When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of
            /// this radius (in meters), and point samples are generated within this sphere.
            /// </summary>
            public float radius;
            
            /// <summary>
            /// When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that
            /// are unoccluded must be greater than this threshold for the pair of probes to be considered
            /// mutually visible.
            /// </summary>
            public float threshold;
            
            /// <summary>
            /// If the distance between two probes is greater than this value, the probes are not considered mutually
            /// visible. Increasing this value can result in simpler paths, at the cost of increased bake times.
            /// </summary>
            public float visRange;
            
            /// <summary>
            /// If the distance between two probes is greater than this value, the probes are considered to
            /// not have any path between them. Increasing this value allows sound to propagate over greater
            /// distances, at the cost of increased bake times and memory usage.
            /// </summary>
            public float pathRange;
            
            /// <summary>
            /// Number of threads to use for baking.
            /// </summary>
            public int numThreads;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLSource_t : IEquatable<_IPLSource_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLSource_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLSource_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLSource_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLSource_t left, _IPLSource_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLSource_t left, _IPLSource_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct _IPLSimulator_t : IEquatable<_IPLSimulator_t>
        {
            private readonly IntPtr _handle;
            
            public _IPLSimulator_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(_IPLSimulator_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is _IPLSimulator_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(_IPLSimulator_t left, _IPLSimulator_t right) => left.Equals(right);
            
            public static bool operator !=(_IPLSimulator_t left, _IPLSimulator_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A distance attenuation model that can be used for modeling attenuation of sound over distance. Can be used
        /// with both direct and indirect sound propagation.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct DistanceAttenuationModel
        {
            /// <summary>
            /// The type of distance attenuation model to use.
            /// </summary>
            public IPL.DistanceAttenuationModelType type;
            
            /// <summary>
            /// When @c type is @c IPL_DISTANCEATTENUATIONTYPE_INVERSEDISTANCE, no distance attenuation is applied to
            /// any sound whose distance from the listener is less than this value.
            /// </summary>
            public float minDistance;
            
            /// <summary>
            /// When @c type is @c IPL_DISTANCEATTENUATIONTYPE_CALLBACK, this function will be called whenever Steam
            /// Audio needs to evaluate distance attenuation.
            /// </summary>
            public IPL.DistanceAttenuationCallback callback;
            
            /// <summary>
            /// Pointer to arbitrary data that will be provided to the @c callback function whenever it is called.
            /// May be @c NULL.
            /// </summary>
            public IntPtr userData;
            
            /// <summary>
            /// Set to @c IPL_TRUE to indicate that the distance attenuation model defined by the @c callback function
            /// has changed since the last time simulation was run. For example, the callback may be evaluating a
            /// curve defined in a GUI. If the user is editing the curve in real-time, set this to @c IPL_TRUE whenever
            /// the curve changes, so Steam Audio can update simulation results to match.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool dirty;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate float DistanceAttenuationCallback(float distance, IntPtr userData);
        
        /// <summary>
        /// An air absorption model that can be used for modeling frequency-dependent attenuation of sound over
        /// distance.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct AirAbsorptionModel
        {
            /// <summary>
            /// The type of air absorption model to use.
            /// </summary>
            public IPL.AirAbsorptionModelType type;
            
            /// <summary>
            /// The exponential falloff coefficients to use when @c type is @c IPL_AIRABSORPTIONTYPE_EXPONENTIAL.
            /// </summary>
            public fixed float coefficients[3];
            
            /// <summary>
            /// When @c type is @c IPL_AIRABSORPTIONTYPE_CALLBACK, this function will be called whenever Steam
            /// Audio needs to evaluate air absorption.
            /// </summary>
            public IPL.AirAbsorptionCallback callback;
            
            /// <summary>
            /// Pointer to arbitrary data that will be provided to the @c callback function whenever it is called.
            /// May be @c NULL.
            /// </summary>
            public IntPtr userData;
            
            /// <summary>
            /// Set to @c IPL_TRUE to indicate that the air absorption model defined by the @c callback function
            /// has changed since the last time simulation was run. For example, the callback may be evaluating a set of 
            /// curves defined in a GUI. If the user is editing the curves in real-time, set this to @c IPL_TRUE whenever
            /// the curves change, so Steam Audio can update simulation results to match.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool dirty;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate float AirAbsorptionCallback(float distance, int band, IntPtr userData);
        
        /// <summary>
        /// A directivity pattern that can be used to model changes in sound intensity as a function of the source's
        /// orientation. Can be used with both direct and indirect sound propagation.
        /// </summary>
        /// <remarks>
        /// The default directivity model is a weighted dipole. This is a linear blend between an omnidirectional
        /// source (which emits sound with equal intensity in all directions), and a dipole oriented along the z-axis
        /// in the source's coordinate system (which focuses sound along the +z and -z axes). A callback function
        /// can be specified to implement any other arbitrary directivity pattern.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Directivity
        {
            /// <summary>
            /// How much of the dipole to blend into the directivity pattern. @c 0 = pure omnidirectional, @c 1 = pure
            /// dipole. @c 0.5f results in a cardioid directivity pattern.
            /// </summary>
            public float dipoleWeight;
            
            /// <summary>
            /// How "sharp" the dipole is. Higher values result in sound being focused within a narrower range of
            /// directions.
            /// </summary>
            public float dipolePower;
            
            /// <summary>
            /// If non @c NULL, this function will be called whenever Steam Audio needs to evaluate a directivity
            /// pattern.
            /// </summary>
            public IPL.DirectivityCallback callback;
            
            /// <summary>
            /// Pointer to arbitrary data that will be provided to the @c callback function whenever it is called.
            /// May be @c NULL.
            /// </summary>
            public IntPtr userData;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate float DirectivityCallback(IPL.Vector3 direction, IntPtr userData);
        
        /// <summary>
        /// Settings used to create a simulator.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SimulationSettings
        {
            /// <summary>
            /// The types of simulation that this simulator will be used for.
            /// </summary>
            public IPL.SimulationFlags flags;
            
            /// <summary>
            /// The type of scene that will be used for simulations via @c iplSimulatorSetScene. The scene type
            /// cannot change during the lifetime of a simulator object.
            /// </summary>
            public IPL.SceneType sceneType;
            
            /// <summary>
            /// The type of reflections effect that will be used to render the results of reflections simulation.
            /// The reflections effect type cannot change during the lifetime of a simulator object.
            /// </summary>
            public IPL.ReflectionEffectType reflectionType;
            
            /// <summary>
            /// The maximum number of point samples to consider when calculating occlusion using the
            /// volumetric occlusion algorithm. Different sources can use different numbers of samples, and the
            /// number of samples can change between simulation runs, but this is the maximum value. Increasing
            /// this value results in smoother occlusion transitions, at the cost of increased CPU usage.
            /// </summary>
            public int maxNumOcclusionSamples;
            
            /// <summary>
            /// The maximum number of rays to trace from the listener when simulating reflections. You can use
            /// different numbers of rays between simulation runs, but this is the maximum value. Increasing
            /// this value results in more accurate reflections, at the cost of increased CPU usage.
            /// </summary>
            public int maxNumRays;
            
            /// <summary>
            /// The number of directions to sample when generating diffusely reflected rays. Increasing this
            /// value may increase the accuracy of diffuse reflections.
            /// </summary>
            public int numDiffuseSamples;
            
            /// <summary>
            /// The maximum length (in seconds) of impulse responses generated by reflection simulations. You
            /// can change this value betweeen simulation runs, but this is the maximum value. Increasing this
            /// value results in longer, more accurate reverb tails, at the cost of increased CPU and memory usage.
            /// </summary>
            public float maxDuration;
            
            /// <summary>
            /// The maximum Ambisonic order of impulse responses generated by reflection simulations. You can
            /// change this value between simulation runs, but this is the maximum value. Increasing this
            /// value results in more accurate directional variations in the impulse responses, at the cost of
            /// increased CPU and memory usage.
            /// </summary>
            public int maxOrder;
            
            /// <summary>
            /// The maximum number of sources for which reflection simulations will be run at any given time.
            /// </summary>
            public int maxNumSources;
            
            /// <summary>
            /// The number of threads used for real-time reflection simulations.
            /// </summary>
            public int numThreads;
            
            /// <summary>
            /// If using custom ray tracer callbacks, this the number of rays that will be passed to the callbacks
            /// every time rays need to be traced.
            /// </summary>
            public int rayBatchSize;
            
            /// <summary>
            /// The number of point samples to consider when calculating probe-to-probe visibility for pathing
            /// simulations. Baked paths may end up being occluded by dynamic objects, in which case you can configure
            /// the simulator to look for alternate paths in real time. This process will involve checking visibility
            /// between probes.
            /// </summary>
            public int numVisSamples;
            
            /// <summary>
            /// The sampling rate (in Hz) used for audio processing.
            /// </summary>
            public int samplingRate;
            
            /// <summary>
            /// The size (in samples) of the audio buffers used for audio processing.
            /// </summary>
            public int frameSize;
            
            /// <summary>
            /// The OpenCL device being used. Only necessary if @sceneType is @c IPL_SCENETYPE_RADEONRAYS, or @c reflectionType is @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public IPL._IPLOpenCLDevice_t openCLDevice;
            
            /// <summary>
            /// The Radeon Rays device being used. Only necessary if @sceneType is @c IPL_SCENETYPE_RADEONRAYS.
            /// </summary>
            public IPL._IPLRadeonRaysDevice_t radeonRaysDevice;
            
            /// <summary>
            /// The TrueAudio Next device being used. Only necessary if @c reflectionType is @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public IPL._IPLTrueAudioNextDevice_t tanDevice;
        }
        
        /// <summary>
        /// Settings used to create a source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SourceSettings
        {
            /// <summary>
            /// The types of simulation that may be run for this source.
            /// </summary>
            public IPL.SimulationFlags flags;
        }
        
        /// <summary>
        /// Simulation parameters for a source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SimulationInputs
        {
            /// <summary>
            /// The types of simulation to run for this source.
            /// </summary>
            public IPL.SimulationFlags flags;
            
            /// <summary>
            /// The types of direct simulation to run for this source.
            /// </summary>
            public IPL.DirectSimulationFlags directFlags;
            
            /// <summary>
            /// The position and orientation of this source.
            /// </summary>
            public IPL.CoordinateSpace3 source;
            
            /// <summary>
            /// The distance attenuation model to use for this source.
            /// </summary>
            public IPL.DistanceAttenuationModel distanceAttenuationModel;
            
            /// <summary>
            /// The air absorption model to use for this source.
            /// </summary>
            public IPL.AirAbsorptionModel airAbsorptionModel;
            
            /// <summary>
            /// The directivity pattern to use for this source.
            /// </summary>
            public IPL.Directivity directivity;
            
            /// <summary>
            /// The occlusion algorithm to use for this source.
            /// </summary>
            public IPL.OcclusionType occlusionType;
            
            /// <summary>
            /// If using volumetric occlusion, the source is modeled as a sphere with this radius.
            /// </summary>
            public float occlusionRadius;
            
            /// <summary>
            /// If using volumetric occlusion, this is the number of point samples to consider when
            /// tracing rays. This value can change between simulation runs.
            /// </summary>
            public int numOcclusionSamples;
            
            /// <summary>
            /// If using parametric or hybrid reverb for rendering reflections, the reverb decay times
            /// for each frequency band are scaled by these values. Set to @c {1.0f, 1.0f, 1.0f} to use
            /// the simulated values without modification.
            /// </summary>
            public fixed float reverbScale[3];
            
            /// <summary>
            /// If using hybrid reverb for rendering reflections, this is the length (in seconds) of
            /// impulse response to use for convolution reverb. The rest of the impulse response will
            /// be used for parametric reverb estimation only. Increasing this value results in more
            /// accurate reflections, at the cost of increased CPU usage.
            /// </summary>
            public float hybridReverbTransitionTime;
            
            /// <summary>
            /// If using hybrid reverb for rendering reflections, this is the amount of overlap between
            /// the convolution and parametric parts. To ensure smooth transitions from the early
            /// convolution part to the late parametric part, the two are cross-faded towards the end of
            /// the convolution part. For example, if @c hybridReverbTransitionTime is @c 1.0f, and 
            /// @c hybridReverbOverlapPercent is @c 0.25f, then the first 0.75 seconds are pure convolution,
            /// the next 0.25 seconds are a blend between convolution and parametric, and the portion of
            /// the tail beyond 1.0 second is pure parametric.
            /// </summary>
            public float hybridReverbOverlapPercent;
            
            /// <summary>
            /// If @c IPL_TRUE, this source will used baked data for reflections simulation.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool baked;
            
            /// <summary>
            /// The identifier used to specify which layer of baked data to use for simulating reflections
            /// for this source.
            /// </summary>
            public IPL.BakedDataIdentifier bakedDataIdentifier;
            
            /// <summary>
            /// The probe batch within which to find paths from this source to the listener.
            /// </summary>
            public IPL._IPLProbeBatch_t pathingProbes;
            
            /// <summary>
            /// When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of
            /// this radius (in meters), and point samples are generated within this sphere.
            /// </summary>
            public float visRadius;
            
            /// <summary>
            /// When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that
            /// are unoccluded must be greater than this threshold for the pair of probes to be considered
            /// mutually visible.
            /// </summary>
            public float visThreshold;
            
            /// <summary>
            /// If the distance between two probes is greater than this value, the probes are not considered mutually
            /// visible. Increasing this value can result in simpler paths, at the cost of increased CPU usage.
            /// </summary>
            public float visRange;
            
            /// <summary>
            /// If simulating pathing, this is the Ambisonic order used for representing path directionality. Higher
            /// values result in more precise spatialization of paths, at the cost of increased CPU usage.
            /// </summary>
            public int pathingOrder;
            
            /// <summary>
            /// If @c IPL_TRUE, baked paths are tested for visibility. This is useful if your scene has dynamic
            /// objects that might occlude baked paths.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool enableValidation;
            
            /// <summary>
            /// If @c IPL_TRUE, and @c enableValidation is @c IPL_TRUE, then if a baked path is occluded by dynamic
            /// geometry, path finding is re-run in real-time to find alternate paths that take into account the
            /// dynamic geometry.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool findAlternatePaths;
        }
        
        /// <summary>
        /// Simulation parameters that are not specific to any source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SimulationSharedInputs
        {
            /// <summary>
            /// The position and orientation of the listener.
            /// </summary>
            public IPL.CoordinateSpace3 listener;
            
            /// <summary>
            /// The number of rays to trace from the listener. Increasing this value results in more accurate 
            /// reflections, at the cost of increased CPU usage.
            /// </summary>
            public int numRays;
            
            /// <summary>
            /// The number of times each ray traced from the listener is reflected when it encounters a solid
            /// object. Increasing this value results in longer, more accurate reverb tails, at the cost of
            /// increased CPU usage during simulation.
            /// </summary>
            public int numBounces;
            
            /// <summary>
            /// The duration (in seconds) of the impulse responses generated when simulating reflections.
            /// Increasing this value results in longer, more accurate reverb tails, at the cost of increased
            /// CPU usage during audio processing.
            /// </summary>
            public float duration;
            
            /// <summary>
            /// The Ambisonic order of the impulse responses generated when simulating reflections. Increasing
            /// this value results in more accurate directional variation of reflected sound, at the cost
            /// of increased CPU usage during audio processing.
            /// </summary>
            public int order;
            
            /// <summary>
            /// When calculating how much sound energy reaches a surface directly from a source, any source that is
            /// closer than @c irradianceMinDistance to the surface is assumed to be at a distance of
            /// @c irradianceMinDistance, for the purposes of energy calculations.
            /// </summary>
            public float irradianceMinDistance;
        }
        
        /// <summary>
        /// Simulation results for a source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SimulationOutputs
        {
            /// <summary>
            /// Direct path simulation results.
            /// </summary>
            public IPL.DirectEffectParams direct;
            
            /// <summary>
            /// Reflection simulation results.
            /// </summary>
            public IPL.ReflectionEffectParams reflections;
            
            /// <summary>
            /// Pathing simulation results.
            /// </summary>
            public IPL.PathEffectParams pathing;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void ProgressCallback(float progress, IntPtr userData);
        
        /// <summary>
        /// Creates a context object. A context must be created before creating any other API objects.
        /// </summary>
        /// <param name="settings">Pointer to the `IPLContextSettings` struct that specifies context creation parameters.</param>
        /// <param name="context">[out] Handle to the created context object.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplContextCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ContextCreate(ref IPL.ContextSettings settings, out IPL._IPLContext_t context);
        
        /// <summary>
        /// Retains an additional reference to a context. The context will not be destroyed until all references are
        /// released.
        /// </summary>
        /// <param name="context">The context to retain a reference to.</param>
        /// <returns>The additional reference to the context.</returns>
        [DllImport(Library, EntryPoint = "iplContextRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLContext_t ContextRetain(IPL._IPLContext_t context);
        
        /// <summary>
        /// Releases a reference to a context. The context will not be destroyed until all references are released.
        /// </summary>
        /// <param name="context">[in, out] The context to release.</param>
        [DllImport(Library, EntryPoint = "iplContextRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ContextRelease(ref IPL._IPLContext_t context);
        
        /// <summary>
        /// Calculates the relative direction from the listener to a sound source. The returned direction
        /// vector is expressed in the listener's coordinate system.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="sourcePosition">World-space coordinates of the source.</param>
        /// <param name="listenerPosition">World-space coordinates of the listener.</param>
        /// <param name="listenerAhead">World-space unit-length vector pointing ahead relative to the listener.</param>
        /// <param name="listenerUp">World-space unit-length vector pointing up relative to the listener.</param>
        /// <returns>A unit-length vector in the listener's coordinate space, pointing from the listener to the source.</returns>
        [DllImport(Library, EntryPoint = "iplCalculateRelativeDirection", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Vector3 CalculateRelativeDirection(IPL._IPLContext_t context, IPL.Vector3 sourcePosition, IPL.Vector3 listenerPosition, IPL.Vector3 listenerAhead, IPL.Vector3 listenerUp);
        
        /// <summary>
        /// Creates a serialized object.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the serialized object.</param>
        /// <param name="serializedObject">[out] The created serialized object.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSerializedObjectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SerializedObjectCreate(IPL._IPLContext_t context, ref IPL.SerializedObjectSettings settings, out IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// Retains an additional reference to a serialized object.
        /// </summary>
        /// <param name="serializedObject">The serialized object to retain a reference to.</param>
        /// <returns>The additional reference to the serialized object.</returns>
        [DllImport(Library, EntryPoint = "iplSerializedObjectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLSerializedObject_t SerializedObjectRetain(IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// Releases a reference to a serialized object.
        /// </summary>
        /// <param name="serializedObject">The serialized object to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSerializedObjectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SerializedObjectRelease(ref IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns>The size in bytes of the serialized data contained in a serialized object.</returns>
        /// <param name="serializedObject">The serialized object.</param>
        [DllImport(Library, EntryPoint = "iplSerializedObjectGetSize", CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong SerializedObjectGetSize(IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns>A pointer to a byte array of serialized data contained in a serialized object.</returns>
        /// <param name="serializedObject">The serialized object.</param>
        [DllImport(Library, EntryPoint = "iplSerializedObjectGetData", CallingConvention = CallingConvention.Cdecl)]
        public static extern ref byte SerializedObjectGetData(IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// Creates an Embree device.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the Embree device.</param>
        /// <param name="device">[out] The created Embree device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplEmbreeDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error EmbreeDeviceCreate(IPL._IPLContext_t context, ref IPL.EmbreeDeviceSettings settings, out IPL._IPLEmbreeDevice_t device);
        
        /// <summary>
        /// Retains an additional reference to an Embree device.
        /// </summary>
        /// <param name="device">The Embree device to retain a reference to.</param>
        /// <returns>The additional reference to the Embree device.</returns>
        [DllImport(Library, EntryPoint = "iplEmbreeDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLEmbreeDevice_t EmbreeDeviceRetain(IPL._IPLEmbreeDevice_t device);
        
        /// <summary>
        /// Releases a reference to an Embree device.
        /// </summary>
        /// <param name="device">The Embree device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplEmbreeDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void EmbreeDeviceRelease(ref IPL._IPLEmbreeDevice_t device);
        
        /// <summary>
        /// Creates an OpenCL device list. This involves listing all available OpenCL devices on the user's system.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The requirements that all listed OpenCL devices must satisfy.</param>
        /// <param name="deviceList">[out] The created OpenCL device list.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error OpenCLDeviceListCreate(IPL._IPLContext_t context, ref IPL.OpenCLDeviceSettings settings, out IPL._IPLOpenCLDeviceList_t deviceList);
        
        /// <summary>
        /// Retains an additional reference to an OpenCL device list.
        /// </summary>
        /// <param name="deviceList">The OpenCL device list to retain a reference to.</param>
        /// <returns>The additional reference to the OpenCL device list.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLOpenCLDeviceList_t OpenCLDeviceListRetain(IPL._IPLOpenCLDeviceList_t deviceList);
        
        /// <summary>
        /// Releases a reference to an OpenCL device list.
        /// </summary>
        /// <param name="deviceList">The OpenCL device list to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void OpenCLDeviceListRelease(ref IPL._IPLOpenCLDeviceList_t deviceList);
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns>The number of devices in an OpenCL device list.</returns>
        /// <param name="deviceList">The OpenCL device list.</param>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListGetNumDevices", CallingConvention = CallingConvention.Cdecl)]
        public static extern int OpenCLDeviceListGetNumDevices(IPL._IPLOpenCLDeviceList_t deviceList);
        
        /// <summary>
        /// Retrieves information about a specific device in an OpenCL device list.
        /// </summary>
        /// <param name="deviceList">The OpenCL device list.</param>
        /// <param name="index">The index of the device within the list.</param>
        /// <param name="deviceDesc">[out] A descriptor for the properties of the specified OpenCL device.</param>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListGetDeviceDesc", CallingConvention = CallingConvention.Cdecl)]
        public static extern void OpenCLDeviceListGetDeviceDesc(IPL._IPLOpenCLDeviceList_t deviceList, int index, out IPL.OpenCLDeviceDesc deviceDesc);
        
        /// <summary>
        /// Creates an OpenCL device. The device is specified as an index into an OpenCL device list.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="deviceList">The OpenCL device list.</param>
        /// <param name="index">The index of the device within the list.</param>
        /// <param name="device">[out] The created OpenCL device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error OpenCLDeviceCreate(IPL._IPLContext_t context, IPL._IPLOpenCLDeviceList_t deviceList, int index, out IPL._IPLOpenCLDevice_t device);
        
        /// <summary>
        /// Creates an OpenCL device from an existing OpenCL device created by your application. Steam Audio will
        /// use up to two command queues that you provide for enqueuing OpenCL computations.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="convolutionQueue">The @c cl_command_queue to use for enqueueing convolution work.</param>
        /// <param name="irUpdateQueue">The @c cl_command_queue to use for enqueueing IR update work.</param>
        /// <param name="device">[out] The created OpenCL device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceCreateFromExisting", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error OpenCLDeviceCreateFromExisting(IPL._IPLContext_t context, IntPtr convolutionQueue, IntPtr irUpdateQueue, out IPL._IPLOpenCLDevice_t device);
        
        /// <summary>
        /// Retains an additional reference to an OpenCL device.
        /// </summary>
        /// <param name="device">The OpenCL device to retain a reference to.</param>
        /// <returns>The additional reference to the OpenCL device.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLOpenCLDevice_t OpenCLDeviceRetain(IPL._IPLOpenCLDevice_t device);
        
        /// <summary>
        /// Releases a reference to an OpenCL device.
        /// </summary>
        /// <param name="device">The OpenCL device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void OpenCLDeviceRelease(ref IPL._IPLOpenCLDevice_t device);
        
        /// <summary>
        /// Creates a Radeon Rays device.
        /// </summary>
        /// <param name="openCLDevice">The OpenCL device to use for running Radeon Rays.</param>
        /// <param name="settings">The settings to use when creating the Radeon Rays device.</param>
        /// <param name="rrDevice">[out] The created Radeon Rays device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplRadeonRaysDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error RadeonRaysDeviceCreate(IPL._IPLOpenCLDevice_t openCLDevice, ref IPL.RadeonRaysDeviceSettings settings, out IPL._IPLRadeonRaysDevice_t rrDevice);
        
        /// <summary>
        /// Retains an additional reference to a Radeon Rays device.
        /// </summary>
        /// <param name="device">The Radeon Rays device to retain a reference to.</param>
        /// <returns>The additional reference to the Radeon Rays device.</returns>
        [DllImport(Library, EntryPoint = "iplRadeonRaysDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLRadeonRaysDevice_t RadeonRaysDeviceRetain(IPL._IPLRadeonRaysDevice_t device);
        
        /// <summary>
        /// Releases a reference to a Radeon Rays device.
        /// </summary>
        /// <param name="device">The Radeon Rays device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplRadeonRaysDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void RadeonRaysDeviceRelease(ref IPL._IPLRadeonRaysDevice_t device);
        
        /// <summary>
        /// Creates a TrueAudio Next device.
        /// </summary>
        /// <param name="openCLDevice">The OpenCL device to use for running TrueAudio Next.</param>
        /// <param name="settings">The settings to use when creating the TrueAudio Next device.</param>
        /// <param name="tanDevice">[out] The created TrueAudio Next device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplTrueAudioNextDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error TrueAudioNextDeviceCreate(IPL._IPLOpenCLDevice_t openCLDevice, ref IPL.TrueAudioNextDeviceSettings settings, out IPL._IPLTrueAudioNextDevice_t tanDevice);
        
        /// <summary>
        /// Retains an additional reference to a TrueAudio Next device.
        /// </summary>
        /// <param name="device">The TrueAudio Next device to retain a reference to.</param>
        /// <returns>The additional reference to the TrueAudio Next device.</returns>
        [DllImport(Library, EntryPoint = "iplTrueAudioNextDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLTrueAudioNextDevice_t TrueAudioNextDeviceRetain(IPL._IPLTrueAudioNextDevice_t device);
        
        /// <summary>
        /// Releases a reference to a TrueAudio Next device.
        /// </summary>
        /// <param name="device">The TrueAudio Next device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplTrueAudioNextDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void TrueAudioNextDeviceRelease(ref IPL._IPLTrueAudioNextDevice_t device);
        
        /// <summary>
        /// Creates a scene.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the scene.</param>
        /// <param name="scene">[out] The created scene.</param>
        /// <returns>Status code indicating success or failure.</returns>
        /// <remarks>
        /// A scene does not store any geometry information on its own; for that you need to create one or more
        /// static meshes or instanced meshes and add them to the scene.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SceneCreate(IPL._IPLContext_t context, ref IPL.SceneSettings settings, out IPL._IPLScene_t scene);
        
        /// <summary>
        /// Retains an additional reference to a scene.
        /// </summary>
        /// <param name="scene">The scene to retain a reference to.</param>
        /// <returns>The additional reference to the scene.</returns>
        [DllImport(Library, EntryPoint = "iplSceneRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLScene_t SceneRetain(IPL._IPLScene_t scene);
        
        /// <summary>
        /// Releases a reference to a scene.
        /// </summary>
        /// <param name="scene">The scene to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSceneRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneRelease(ref IPL._IPLScene_t scene);
        
        /// <summary>
        /// Loads a scene from a serialized object. Typically, the serialized object will be created from a byte array
        /// loaded from disk or over the network.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the scene.</param>
        /// <param name="serializedObject">The serialized object from which to load the scene.</param>
        /// <param name="progressCallback">Callback that reports the percentage of this function's work that has been completed. May be @c NULL.</param>
        /// <param name="progressCallbackUserData">Pointer to arbitrary data that will be passed to the progress callback. May be @c NULL.</param>
        /// <param name="scene">[out] The created scene.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSceneLoad", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SceneLoad(IPL._IPLContext_t context, ref IPL.SceneSettings settings, IPL._IPLSerializedObject_t serializedObject, IPL.ProgressCallback progressCallback, IntPtr progressCallbackUserData, out IPL._IPLScene_t scene);
        
        /// <summary>
        /// Saves a scene to a serialized object. Typically, the serialized object will then be saved to disk.
        /// </summary>
        /// <param name="scene">The scene to save.</param>
        /// <param name="serializedObject">The serialized object into which to save the scene.</param>
        /// <remarks>
        /// *This function can only be called on a scene created with @c IPL_SCENETYPE_DEFAULT.**
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneSave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneSave(IPL._IPLScene_t scene, IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// Saves a scene to an OBJ file.
        /// </summary>
        /// <param name="scene">The scene to save.</param>
        /// <param name="fileBaseName">Absolute or relative path to the OBJ file to generate.</param>
        /// <remarks>
        /// An OBJ file is a widely-supported 3D model file format, that can be displayed using a variety of software 
        /// on most PC platforms. The OBJ file generated by this function can be useful for detecting problems that 
        /// occur when exporting scene data from your application to Steam Audio.*This function can only be called on a scene created with @c IPL_SCENETYPE_DEFAULT or @c IPL_SCENETYPE_EMBREE.**
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneSaveOBJ", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneSaveOBJ(IPL._IPLScene_t scene, [MarshalAs(UnmanagedType.LPStr)] string fileBaseName);
        
        /// <summary>
        /// Commits any changes to the scene.
        /// </summary>
        /// <param name="scene">The scene to commit changes to.</param>
        /// <remarks>
        /// This function should be called after any calls to the following functions, for the changes to take effect:-   @c iplStaticMeshAdd -   @c iplStaticMeshRemove -   @c iplInstancedMeshAdd -   @c iplInstancedMeshRemove -   @c iplInstancedMeshUpdateTransform For best performance, call this function once after all changes have been made for a given frame.*This function cannot be called concurrently with any simulation functions.**
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneCommit", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneCommit(IPL._IPLScene_t scene);
        
        /// <summary>
        /// Creates a static mesh.
        /// </summary>
        /// <param name="scene">The scene in which the static mesh should be created.</param>
        /// <param name="settings">The settings to use when creating the static mesh.</param>
        /// <param name="staticMesh">[out] The created static mesh.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// A static mesh represents a triangle mesh that does not change after it is created. A static mesh also contains 
        /// an array of acoustic material properties, and a mapping between each of its triangles and their acoustic material 
        /// properties.Static mesh objects should be used for scene geometry that is guaranteed to never change, such as rooms, 
        /// buildings, or triangulated terrain. A scene may contain multiple static meshes, although typically one 
        /// is sufficient.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error StaticMeshCreate(IPL._IPLScene_t scene, ref IPL.StaticMeshSettings settings, out IPL._IPLStaticMesh_t staticMesh);
        
        /// <summary>
        /// Retains an additional reference to a static mesh.
        /// </summary>
        /// <param name="staticMesh">The static mesh to retain a reference to.</param>
        /// <returns>The additional reference to the static mesh.</returns>
        [DllImport(Library, EntryPoint = "iplStaticMeshRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLStaticMesh_t StaticMeshRetain(IPL._IPLStaticMesh_t staticMesh);
        
        /// <summary>
        /// Releases a reference to a static mesh.
        /// </summary>
        /// <param name="staticMesh">The static mesh to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplStaticMeshRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshRelease(ref IPL._IPLStaticMesh_t staticMesh);
        
        /// <summary>
        /// Loads a static mesh from a serialized object. Typically, the serialized object will be created from a byte array
        /// loaded from disk or over the network.
        /// </summary>
        /// <param name="scene">The scene in which the static mesh should be created.</param>
        /// <param name="serializedObject">The serialized object from which to load the scene.</param>
        /// <param name="progressCallback">Callback that reports the percentage of this function's work that has been completed. May be @c NULL.</param>
        /// <param name="progressCallbackUserData">Pointer to arbitrary data that will be passed to the progress callback. May be @c NULL.</param>
        /// <param name="staticMesh">[out] The created static mesh.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplStaticMeshLoad", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error StaticMeshLoad(IPL._IPLScene_t scene, IPL._IPLSerializedObject_t serializedObject, IPL.ProgressCallback progressCallback, IntPtr progressCallbackUserData, out IPL._IPLStaticMesh_t staticMesh);
        
        /// <summary>
        /// Saves a static mesh to a serialized object. Typically, the serialized object will then be saved to disk.
        /// </summary>
        /// <param name="staticMesh">The static mesh to save.</param>
        /// <param name="serializedObject">The serialized object into which to save the static mesh.</param>
        /// <remarks>
        /// This function can only be called on a static mesh that is part of a scene created with @c IPL_SCENETYPE_DEFAULT.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshSave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshSave(IPL._IPLStaticMesh_t staticMesh, IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// Adds a static mesh to a scene.
        /// </summary>
        /// <param name="staticMesh">The static mesh to add.</param>
        /// <param name="scene">The scene to which to add the static mesh. This must be the scene which was passed when
        /// calling @c iplStaticMeshCreate.</param>
        /// <remarks>
        /// This function should be called after @c iplStaticMeshCreate, or at any point after @c iplStaticMeshRemove, for the static mesh to start affecting sound propagation.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshAdd", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshAdd(IPL._IPLStaticMesh_t staticMesh, IPL._IPLScene_t scene);
        
        /// <summary>
        /// Removes a static mesh from a scene.
        /// </summary>
        /// <param name="staticMesh">The static mesh to remove.</param>
        /// <param name="scene">The scene from which to remove the static mesh. This must be the scene which was passed when
        /// calling @c iplStaticMeshCreate.</param>
        /// <remarks>
        /// After this function is called, the static mesh will stop affecting sound propagation, until it is
        /// added back using @c iplStaticMeshAdd.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshRemove", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshRemove(IPL._IPLStaticMesh_t staticMesh, IPL._IPLScene_t scene);
        
        /// <summary>
        /// Creates an instanced mesh.
        /// </summary>
        /// <param name="scene">The scene in which the instanced mesh should be created.</param>
        /// <param name="settings">The settings used to create the instanced mesh.</param>
        /// <param name="instancedMesh">[out] The created instanced mesh.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// An instanced mesh takes one scene and positions it within another scene. This is useful if you have the
        /// same object, like a pillar, that you want to instantiate multiple times within the same scene. A scene
        /// can be instantiated multiple times within another scene, without incurring any significant memory overhead.The instanced mesh can be moved, rotated, and scaled freely at any time, providing an easy way to implement
        /// dynamic objects whose motion can be described purely in terms of rigid-body transformations.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error InstancedMeshCreate(IPL._IPLScene_t scene, ref IPL.InstancedMeshSettings settings, out IPL._IPLInstancedMesh_t instancedMesh);
        
        /// <summary>
        /// Retains an additional reference to a instanced mesh.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to retain a reference to.</param>
        /// <returns>The additional reference to the instanced mesh.</returns>
        [DllImport(Library, EntryPoint = "iplInstancedMeshRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLInstancedMesh_t InstancedMeshRetain(IPL._IPLInstancedMesh_t instancedMesh);
        
        /// <summary>
        /// Releases a reference to a instanced mesh.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplInstancedMeshRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshRelease(ref IPL._IPLInstancedMesh_t instancedMesh);
        
        /// <summary>
        /// Adds an instanced mesh to a scene.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to add.</param>
        /// <param name="scene">The scene to which to add the instanced mesh. This must be the scene which was passed when
        /// calling @c iplInstancedMeshCreate.</param>
        /// <remarks>
        /// This function should be called after @c iplInstancedMeshCreate, or at any point after @c iplInstancedMeshRemove, for the instanced mesh to start affecting sound propagation.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshAdd", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshAdd(IPL._IPLInstancedMesh_t instancedMesh, IPL._IPLScene_t scene);
        
        /// <summary>
        /// Removes an instanced mesh from a scene.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to remove.</param>
        /// <param name="scene">The scene from which to remove the instanced mesh. This must be the scene which was passed when
        /// calling @c iplInstancedMeshCreate.</param>
        /// <remarks>
        /// After this function is called, the instanced mesh will stop affecting sound propagation, until it is
        /// added back using @c iplInstancedMeshAdd.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshRemove", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshRemove(IPL._IPLInstancedMesh_t instancedMesh, IPL._IPLScene_t scene);
        
        /// <summary>
        /// Updates the local-to-world transform of an instanced mesh within its parent scene.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh whose transform is to be updated.</param>
        /// <param name="scene">The parent scene that contains the instanced mesh.</param>
        /// <param name="transform">The new 4x4 local-to-world transform matrix.</param>
        /// <remarks>
        /// This function allows the instanced mesh to be moved, rotated, and scaled dynamically.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshUpdateTransform", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshUpdateTransform(IPL._IPLInstancedMesh_t instancedMesh, IPL._IPLScene_t scene, IPL.Matrix4x4 transform);
        
        /// <summary>
        /// Allocates an audio buffer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="numChannels">Number of channels.</param>
        /// <param name="numSamples">Number of samples per channel.</param>
        /// <param name="audioBuffer">The audio buffer to allocate.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// All audio buffers are uncompressed PCM with 32-bit floating-point samples.Internally, all audio buffers are stored deinterleaved for performance reasons. If your audio engine provides
        /// interleaved audio buffers, you must use @c iplAudioBufferInterleave and @c iplAudioBufferDeinterleave to explicitly
        /// convert to/from deinterleaved format. If your audio engine provides deinterleaved audio buffers, you can
        /// pass them directly using @c IPLAudioBuffer, thus avoiding the processing and memory overhead of an extra audio buffer.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferAllocate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AudioBufferAllocate(IPL._IPLContext_t context, int numChannels, int numSamples, ref IPL.AudioBuffer audioBuffer);
        
        /// <summary>
        /// Frees an audio buffer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioBuffer">The audio buffer to free.</param>
        [DllImport(Library, EntryPoint = "iplAudioBufferFree", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferFree(IPL._IPLContext_t context, ref IPL.AudioBuffer audioBuffer);
        
        /// <summary>
        /// Reads samples from an audio buffer and interleaves them into a user-provided array.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="src">The audio buffer to read from.</param>
        /// <param name="dst">The interleaved array to write into.</param>
        [DllImport(Library, EntryPoint = "iplAudioBufferInterleave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferInterleave(IPL._IPLContext_t context, ref IPL.AudioBuffer src, ref float dst);
        
        /// <summary>
        /// Writes interleaved samples from a user-provided array into an audio buffer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="src">The interleaved array to read from.</param>
        /// <param name="dst">The audio buffer to write into.</param>
        [DllImport(Library, EntryPoint = "iplAudioBufferDeinterleave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferDeinterleave(IPL._IPLContext_t context, ref float src, ref IPL.AudioBuffer dst);
        
        /// <summary>
        /// Mixes one audio buffer into another.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="in">The source audio buffer.</param>
        /// <param name="mix">The destination audio buffer, into which the source should be mixed.</param>
        /// <remarks>
        /// Both audio buffers must have the same number of channels and samples.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferMix", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferMix(IPL._IPLContext_t context, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer mix);
        
        /// <summary>
        /// Downmixes a multi-channel audio buffer into a mono audio buffer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="in">The source audio buffer.</param>
        /// <param name="out">The destination audio buffer.</param>
        /// <remarks>
        /// Both audio buffers must have the same number of samples.Downmixing is performed by summing up the source channels and dividing the result by the
        /// number of source channels. If this is not the desired downmixing behavior, we recommend
        /// that downmixing be performed manually.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferDownmix", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferDownmix(IPL._IPLContext_t context, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Converts an Ambisonic audio buffer from one Ambisonic format to another.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="inType">Ambisonic format of @c in.</param>
        /// <param name="outType">Ambisonic format that @c out should be in.</param>
        /// <param name="in">The source audio buffer.</param>
        /// <param name="out">The destination audio buffer.</param>
        /// <remarks>
        /// Both audio buffers must have the same number of samples.This conversion can be applied in-place, i.e., @c in and @c out can be the same 
        /// audio buffer.Steam Audio's "native" Ambisonic format is N3D, so for best performance, keep all
        /// Ambisonic data in N3D format except when exchanging data with your audio engine.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferConvertAmbisonics", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferConvertAmbisonics(IPL._IPLContext_t context, IPL.AmbisonicsType inType, IPL.AmbisonicsType outType, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an HRTF.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="hrtfSettings">The settings used to create the HRTF object.</param>
        /// <param name="hrtf">[out] The created HRTF object.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// Calling this function is somewhat expensive; avoid creating HRTF objects in your audio thread at all 
        /// if possible.This function is not thread-safe. Do not simultaneously call it from multiple threads.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplHRTFCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error HRTFCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.HRTFSettings hrtfSettings, out IPL._IPLHRTF_t hrtf);
        
        /// <summary>
        /// Retains an additional reference to an HRTF object.
        /// </summary>
        /// <param name="hrtf">The HRTF object to retain a reference to.</param>
        /// <returns>The additional reference to the HRTF object.</returns>
        [DllImport(Library, EntryPoint = "iplHRTFRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLHRTF_t HRTFRetain(IPL._IPLHRTF_t hrtf);
        
        /// <summary>
        /// Releases a reference to an HRTF object.
        /// </summary>
        /// <param name="hrtf">The HRTF object to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplHRTFRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void HRTFRelease(ref IPL._IPLHRTF_t hrtf);
        
        /// <summary>
        /// Creates a panning effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the panning effect.</param>
        /// <param name="effect">[out] The created panning effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplPanningEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error PanningEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.PanningEffectSettings effectSettings, out IPL._IPLPanningEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to a panning effect.
        /// </summary>
        /// <param name="effect">The panning effect to retain a reference to.</param>
        /// <returns>The additional reference to the panning effect.</returns>
        [DllImport(Library, EntryPoint = "iplPanningEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLPanningEffect_t PanningEffectRetain(IPL._IPLPanningEffect_t effect);
        
        /// <summary>
        /// Releases a reference to a panning effect.
        /// </summary>
        /// <param name="effect">The panning effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplPanningEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PanningEffectRelease(ref IPL._IPLPanningEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of a panning effect.
        /// </summary>
        /// <param name="effect">The panning effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplPanningEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PanningEffectReset(IPL._IPLPanningEffect_t effect);
        
        /// <summary>
        /// Applies a panning effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The panning effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must be 1-channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the panning effect. For example, if the speaker layout is
        /// @c IPL_SPEAKERLAYOUTTYPE_SURROUND_5_1, the output buffer must contain 6 channels.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplPanningEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState PanningEffectApply(IPL._IPLPanningEffect_t effect, ref IPL.PanningEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a binaural effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the binaural effect.</param>
        /// <param name="effect">[out] The created binaural effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplBinauralEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error BinauralEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.BinauralEffectSettings effectSettings, out IPL._IPLBinauralEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to a binaural effect.
        /// </summary>
        /// <param name="effect">The binaural effect to retain a reference to.</param>
        /// <returns>The additional reference to the binaural effect.</returns>
        [DllImport(Library, EntryPoint = "iplBinauralEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLBinauralEffect_t BinauralEffectRetain(IPL._IPLBinauralEffect_t effect);
        
        /// <summary>
        /// Releases a reference to a binaural effect.
        /// </summary>
        /// <param name="effect">The binaural effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplBinauralEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void BinauralEffectRelease(ref IPL._IPLBinauralEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of a binaural effect.
        /// </summary>
        /// <param name="effect">The binaural effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplBinauralEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void BinauralEffectReset(IPL._IPLBinauralEffect_t effect);
        
        /// <summary>
        /// Applies a binaural effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The binaural effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must be 1- or 2-channel.</param>
        /// <param name="out">The output audio buffer. Must be 2-channel.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplBinauralEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState BinauralEffectApply(IPL._IPLBinauralEffect_t effect, ref IPL.BinauralEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a virtual surround effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the virtual surround effect.</param>
        /// <param name="effect">[out] The created virtual surround effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error VirtualSurroundEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.VirtualSurroundEffectSettings effectSettings, out IPL._IPLVirtualSurroundEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to a virtual surround effect.
        /// </summary>
        /// <param name="effect">The virtual surround effect to retain a reference to.</param>
        /// <returns>The additional reference to the virtual surround effect.</returns>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLVirtualSurroundEffect_t VirtualSurroundEffectRetain(IPL._IPLVirtualSurroundEffect_t effect);
        
        /// <summary>
        /// Releases a reference to a virtual surround effect.
        /// </summary>
        /// <param name="effect">The virtual surround effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void VirtualSurroundEffectRelease(ref IPL._IPLVirtualSurroundEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of a virtual surround effect.
        /// </summary>
        /// <param name="effect">The virtual surround effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void VirtualSurroundEffectReset(IPL._IPLVirtualSurroundEffect_t effect);
        
        /// <summary>
        /// Applies a virtual surround effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The virtual surround effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the virtual surround effect.</param>
        /// <param name="out">The output audio buffer. Must be 2-channel.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState VirtualSurroundEffectApply(IPL._IPLVirtualSurroundEffect_t effect, ref IPL.VirtualSurroundEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics encode effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics encode effect.</param>
        /// <param name="effect">[out] The created Ambisonics encode effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsEncodeEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.AmbisonicsEncodeEffectSettings effectSettings, out IPL._IPLAmbisonicsEncodeEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics encode effect.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics encode effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLAmbisonicsEncodeEffect_t AmbisonicsEncodeEffectRetain(IPL._IPLAmbisonicsEncodeEffect_t effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics encode effect.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsEncodeEffectRelease(ref IPL._IPLAmbisonicsEncodeEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics encode effect.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsEncodeEffectReset(IPL._IPLAmbisonicsEncodeEffect_t effect);
        
        /// <summary>
        /// Applies an Ambisonics encode effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must be 1-channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the
        /// Ambisonics order specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsEncodeEffectApply(IPL._IPLAmbisonicsEncodeEffect_t effect, ref IPL.AmbisonicsEncodeEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics panning effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics panning effect.</param>
        /// <param name="effect">[out] The created Ambisonics panning effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsPanningEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.AmbisonicsPanningEffectSettings effectSettings, out IPL._IPLAmbisonicsPanningEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics panning effect.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics panning effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLAmbisonicsPanningEffect_t AmbisonicsPanningEffectRetain(IPL._IPLAmbisonicsPanningEffect_t effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics panning effect.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsPanningEffectRelease(ref IPL._IPLAmbisonicsPanningEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics panning effect.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsPanningEffectReset(IPL._IPLAmbisonicsPanningEffect_t effect);
        
        /// <summary>
        /// Applies an Ambisonics panning effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified in the parameters.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsPanningEffectApply(IPL._IPLAmbisonicsPanningEffect_t effect, ref IPL.AmbisonicsPanningEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics binaural effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics binaural effect.</param>
        /// <param name="effect">[out] The created Ambisonics binaural effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsBinauralEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.AmbisonicsBinauralEffectSettings effectSettings, out IPL._IPLAmbisonicsBinauralEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics binaural effect.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics binaural effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLAmbisonicsBinauralEffect_t AmbisonicsBinauralEffectRetain(IPL._IPLAmbisonicsBinauralEffect_t effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics binaural effect.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsBinauralEffectRelease(ref IPL._IPLAmbisonicsBinauralEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics binaural effect.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsBinauralEffectReset(IPL._IPLAmbisonicsBinauralEffect_t effect);
        
        /// <summary>
        /// Applies an Ambisonics binaural effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified in the parameters.</param>
        /// <param name="out">The output audio buffer. Must have 2 channels.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsBinauralEffectApply(IPL._IPLAmbisonicsBinauralEffect_t effect, ref IPL.AmbisonicsBinauralEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics rotation effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics rotation effect.</param>
        /// <param name="effect">[out] The created Ambisonics rotation effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsRotationEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.AmbisonicsRotationEffectSettings effectSettings, out IPL._IPLAmbisonicsRotationEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics rotation effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLAmbisonicsRotationEffect_t AmbisonicsRotationEffectRetain(IPL._IPLAmbisonicsRotationEffect_t effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsRotationEffectRelease(ref IPL._IPLAmbisonicsRotationEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsRotationEffectReset(IPL._IPLAmbisonicsRotationEffect_t effect);
        
        /// <summary>
        /// Applies an Ambisonics rotation effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified when creating the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsRotationEffectApply(IPL._IPLAmbisonicsRotationEffect_t effect, ref IPL.AmbisonicsRotationEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics rotation effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics rotation effect.</param>
        /// <param name="effect">[out] The created Ambisonics rotation effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsDecodeEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.AmbisonicsDecodeEffectSettings effectSettings, out IPL._IPLAmbisonicsDecodeEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics rotation effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLAmbisonicsDecodeEffect_t AmbisonicsDecodeEffectRetain(IPL._IPLAmbisonicsDecodeEffect_t effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsDecodeEffectRelease(ref IPL._IPLAmbisonicsDecodeEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsDecodeEffectReset(IPL._IPLAmbisonicsDecodeEffect_t effect);
        
        /// <summary>
        /// Applies an Ambisonics decode effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics decode effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified when creating the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the effect (if using panning) or 2 channels (if using
        /// binaural rendering).</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsDecodeEffectApply(IPL._IPLAmbisonicsDecodeEffect_t effect, ref IPL.AmbisonicsDecodeEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a direct effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the direct effect.</param>
        /// <param name="effect">[out] The created direct effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplDirectEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error DirectEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.DirectEffectSettings effectSettings, out IPL._IPLDirectEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to a direct effect.
        /// </summary>
        /// <param name="effect">The direct effect to retain a reference to.</param>
        /// <returns>The additional reference to the direct effect.</returns>
        [DllImport(Library, EntryPoint = "iplDirectEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLDirectEffect_t DirectEffectRetain(IPL._IPLDirectEffect_t effect);
        
        /// <summary>
        /// Releases a reference to a direct effect.
        /// </summary>
        /// <param name="effect">The direct effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplDirectEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void DirectEffectRelease(ref IPL._IPLDirectEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of a direct effect.
        /// </summary>
        /// <param name="effect">The direct effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplDirectEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void DirectEffectReset(IPL._IPLDirectEffect_t effect);
        
        /// <summary>
        /// Applies a direct effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The direct effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as specified when creating the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CAN be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplDirectEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState DirectEffectApply(IPL._IPLDirectEffect_t effect, ref IPL.DirectEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a reflection effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the reflection effect.</param>
        /// <param name="effect">[out] The created reflection effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ReflectionEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.ReflectionEffectSettings effectSettings, out IPL._IPLReflectionEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to a reflection effect.
        /// </summary>
        /// <param name="effect">The reflection effect to retain a reference to.</param>
        /// <returns>The additional reference to the reflection effect.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLReflectionEffect_t ReflectionEffectRetain(IPL._IPLReflectionEffect_t effect);
        
        /// <summary>
        /// Releases a reference to a reflection effect.
        /// </summary>
        /// <param name="effect">The reflection effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplReflectionEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionEffectRelease(ref IPL._IPLReflectionEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of a reflection effect.
        /// </summary>
        /// <param name="effect">The reflection effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplReflectionEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionEffectReset(IPL._IPLReflectionEffect_t effect);
        
        /// <summary>
        /// Applies a reflection effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The reflection effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have 1 channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as the impulse response
        /// specified when creating the effect (for convolution, hybrid, and TAN) or at
        /// least 1 channel (for parametric).</param>
        /// <param name="mixer">If this is non-null, then the output of this effect will be mixed into the given
        /// mixer object instead of being returned in the @c out parameter. The mixed output can
        /// be retrieved elsewhere in the audio pipeline using @c iplReflectionMixerApply. This
        /// can have a performance benefit if using convolution. If using TAN, specifying
        /// a mixer is required.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplReflectionEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState ReflectionEffectApply(IPL._IPLReflectionEffect_t effect, ref IPL.ReflectionEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out, IPL._IPLReflectionMixer_t mixer);
        
        /// <summary>
        /// Creates a reflection effect mixer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings used when creating the reflection effects that will be mixed into
        /// this reflection mixer.</param>
        /// <param name="mixer">[out] The created reflection mixer.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionMixerCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ReflectionMixerCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.ReflectionEffectSettings effectSettings, out IPL._IPLReflectionMixer_t mixer);
        
        /// <summary>
        /// Retains an additional reference to a reflection mixer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to retain a reference to.</param>
        /// <returns>The additional reference to the reflection mixer.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionMixerRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLReflectionMixer_t ReflectionMixerRetain(IPL._IPLReflectionMixer_t mixer);
        
        /// <summary>
        /// Releases a reference to a reflection mixer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplReflectionMixerRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionMixerRelease(ref IPL._IPLReflectionMixer_t mixer);
        
        /// <summary>
        /// Resets the internal processing state of a reflection mixer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to reset.</param>
        [DllImport(Library, EntryPoint = "iplReflectionMixerReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionMixerReset(IPL._IPLReflectionMixer_t mixer);
        
        /// <summary>
        /// Retrieves the contents of a reflection mixer and places it into an audio buffer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to retrieve audio from.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as the impulse response
        /// specified when creating the mixer.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionMixerApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState ReflectionMixerApply(IPL._IPLReflectionMixer_t mixer, ref IPL.ReflectionEffectParams @params, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a path effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the path effect.</param>
        /// <param name="effect">[out] The created path effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplPathEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error PathEffectCreate(IPL._IPLContext_t context, ref IPL.AudioSettings audioSettings, ref IPL.PathEffectSettings effectSettings, out IPL._IPLPathEffect_t effect);
        
        /// <summary>
        /// Retains an additional reference to a path effect.
        /// </summary>
        /// <param name="effect">The path effect to retain a reference to.</param>
        /// <returns>The additional reference to the path effect.</returns>
        [DllImport(Library, EntryPoint = "iplPathEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLPathEffect_t PathEffectRetain(IPL._IPLPathEffect_t effect);
        
        /// <summary>
        /// Releases a reference to a path effect.
        /// </summary>
        /// <param name="effect">The path effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplPathEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathEffectRelease(ref IPL._IPLPathEffect_t effect);
        
        /// <summary>
        /// Resets the internal processing state of a path effect.
        /// </summary>
        /// <param name="effect">The path effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplPathEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathEffectReset(IPL._IPLPathEffect_t effect);
        
        /// <summary>
        /// Applies a path effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The path effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have 1 channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the
        /// Ambisonics order specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplPathEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState PathEffectApply(IPL._IPLPathEffect_t effect, ref IPL.PathEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an empty probe array.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="probeArray">[out] The created probe array.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplProbeArrayCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ProbeArrayCreate(IPL._IPLContext_t context, out IPL._IPLProbeArray_t probeArray);
        
        /// <summary>
        /// Retains an additional reference to a probe array.
        /// </summary>
        /// <param name="probeArray">The probe array to retain a reference to.</param>
        /// <returns>The additional reference to the probe array.</returns>
        [DllImport(Library, EntryPoint = "iplProbeArrayRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLProbeArray_t ProbeArrayRetain(IPL._IPLProbeArray_t probeArray);
        
        /// <summary>
        /// Releases a reference to a probe array.
        /// </summary>
        /// <param name="probeArray">The probe array to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplProbeArrayRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeArrayRelease(ref IPL._IPLProbeArray_t probeArray);
        
        /// <summary>
        /// Generates probes and adds them to a probe array.
        /// </summary>
        /// <param name="scene">The scene in which to generate probes.</param>
        /// <param name="params">Parameters to use for generating probes.</param>
        /// <param name="probeArray">The array into which to add the generated probes.</param>
        [DllImport(Library, EntryPoint = "iplProbeArrayGenerateProbes", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeArrayGenerateProbes(IPL._IPLProbeArray_t probeArray, IPL._IPLScene_t scene, ref IPL.ProbeGenerationParams @params);
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns>The number of probes in a probe array.</returns>
        /// <param name="probeArray">The probe array.</param>
        [DllImport(Library, EntryPoint = "iplProbeArrayGetNumProbes", CallingConvention = CallingConvention.Cdecl)]
        public static extern int ProbeArrayGetNumProbes(IPL._IPLProbeArray_t probeArray);
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns>The probe at a given index in a probe array.</returns>
        /// <param name="probeArray">The probe array.</param>
        /// <param name="index">Index of the probe within the array.</param>
        [DllImport(Library, EntryPoint = "iplProbeArrayGetProbe", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Sphere ProbeArrayGetProbe(IPL._IPLProbeArray_t probeArray, int index);
        
        /// <summary>
        /// Creates an empty probe batch.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="probeBatch">[out] The created probe batch.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ProbeBatchCreate(IPL._IPLContext_t context, out IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Retains an additional reference to a probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to retain a reference to.</param>
        /// <returns>The additional reference to the probe batch.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLProbeBatch_t ProbeBatchRetain(IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Releases a reference to a probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchRelease(ref IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Loads a probe batch from a serialized object. Typically, the serialized object will be created from a byte array
        /// loaded from disk or over the network.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="serializedObject">The serialized object from which to load the probe batch.</param>
        /// <param name="probeBatch">[out] The created probe batch.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchLoad", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ProbeBatchLoad(IPL._IPLContext_t context, IPL._IPLSerializedObject_t serializedObject, out IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Saves a probe batch to a serialized object. Typically, the serialized object will then be saved to disk.
        /// </summary>
        /// <param name="probeBatch">The probe batch to save.</param>
        /// <param name="serializedObject">The serialized object into which to save the probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchSave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchSave(IPL._IPLProbeBatch_t probeBatch, IPL._IPLSerializedObject_t serializedObject);
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns>The number of probes in a probe batch.</returns>
        /// <param name="probeBatch">The probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchGetNumProbes", CallingConvention = CallingConvention.Cdecl)]
        public static extern int ProbeBatchGetNumProbes(IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Adds a probe to a batch. The new probe will be added as the last probe in the batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch.</param>
        /// <param name="probe">The probe to add.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchAddProbe", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchAddProbe(IPL._IPLProbeBatch_t probeBatch, IPL.Sphere probe);
        
        /// <summary>
        /// Adds every probe in an array to a batch. The new probes will be added, in order, at the end of the batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch.</param>
        /// <param name="probeArray">The probe array containing the probes to add.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchAddProbeArray", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchAddProbeArray(IPL._IPLProbeBatch_t probeBatch, IPL._IPLProbeArray_t probeArray);
        
        /// <summary>
        /// Removes a probe from a batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch.</param>
        /// <param name="index">Index of the probe to remove.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchRemoveProbe", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchRemoveProbe(IPL._IPLProbeBatch_t probeBatch, int index);
        
        /// <summary>
        /// Commits all changes made to a probe batch since this function was last called (or since the probe batch was
        /// first created, if this function was never called). This function must be called after adding, removing, or
        /// updating any probes in the batch, for the changes to take effect.
        /// </summary>
        /// <param name="probeBatch">The probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchCommit", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchCommit(IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Deletes a specific layer of data from a probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch.</param>
        /// <param name="identifier">The identifier of the baked data layer to delete.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchRemoveData", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchRemoveData(IPL._IPLProbeBatch_t probeBatch, ref IPL.BakedDataIdentifier identifier);
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns>The size (in bytes) of a specific baked data layer in a probe batch.</returns>
        /// <param name="probeBatch">The probe batch.</param>
        /// <param name="identifier">The identifier of the baked data layer.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchGetDataSize", CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong ProbeBatchGetDataSize(IPL._IPLProbeBatch_t probeBatch, ref IPL.BakedDataIdentifier identifier);
        
        /// <summary>
        /// Bakes a single layer of reflections data in a probe batch.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="params">Parameters to use for baking reflections data.</param>
        /// <param name="progressCallback">(Optional) This function will be called by Steam Audio to notify your application
        /// as the bake progresses. Use this to display a progress bar or some other indicator
        /// that the bake is running.</param>
        /// <param name="userData">(Optional) Pointer to arbitrary data that will be sent to the progress callback
        /// when Steam Audio calls it.</param>
        /// <remarks>
        /// Only one bake can be in progress at any point in time.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplReflectionsBakerBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionsBakerBake(IPL._IPLContext_t context, ref IPL.ReflectionsBakeParams @params, IPL.ProgressCallback progressCallback, IntPtr userData);
        
        /// <summary>
        /// Cancels any running bakes of reflections data.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        [DllImport(Library, EntryPoint = "iplReflectionsBakerCancelBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionsBakerCancelBake(IPL._IPLContext_t context);
        
        /// <summary>
        /// Bakes a single layer of pathing data in a probe batch.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="params">Parameters to use for baking pathing data.</param>
        /// <param name="progressCallback">(Optional) This function will be called by Steam Audio to notify your application
        /// as the bake progresses. Use this to display a progress bar or some other indicator
        /// that the bake is running.</param>
        /// <param name="userData">(Optional) Pointer to arbitrary data that will be sent to the progress callback
        /// when Steam Audio calls it.</param>
        /// <remarks>
        /// Only one bake can be in progress at any point in time.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplPathBakerBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathBakerBake(IPL._IPLContext_t context, ref IPL.PathBakeParams @params, IPL.ProgressCallback progressCallback, IntPtr userData);
        
        /// <summary>
        /// Cancels any running bakes of pathing data.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        [DllImport(Library, EntryPoint = "iplPathBakerCancelBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathBakerCancelBake(IPL._IPLContext_t context);
        
        /// <summary>
        /// Creates a simulator.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the simulator.</param>
        /// <param name="simulator">[out] The created simulator.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSimulatorCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SimulatorCreate(IPL._IPLContext_t context, ref IPL.SimulationSettings settings, out IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Retains an additional reference to a simulator.
        /// </summary>
        /// <param name="simulator">The simulator to retain a reference to.</param>
        /// <returns>The additional reference to the simulator.</returns>
        [DllImport(Library, EntryPoint = "iplSimulatorRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLSimulator_t SimulatorRetain(IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Releases a reference to a simulator.
        /// </summary>
        /// <param name="simulator">The simulator to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSimulatorRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRelease(ref IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Specifies the scene within which all subsequent simulations should be run.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <param name="scene">The scene to use for simulations.</param>
        /// <remarks>
        /// Call @c iplSimulatorCommit after calling this function for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorSetScene", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorSetScene(IPL._IPLSimulator_t simulator, IPL._IPLScene_t scene);
        
        /// <summary>
        /// Adds a probe batch for use in subsequent simulations. Sources that require baked data can then use the
        /// data contained in the specified probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to add.</param>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// Call @c iplSimulatorCommit after calling this function for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorAddProbeBatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorAddProbeBatch(IPL._IPLSimulator_t simulator, IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Removed a probe batch from use in subsequent simulations. Sources that require baked data will then stop using the
        /// data contained in the specified probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to remove.</param>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// Call @c iplSimulatorCommit after calling this function for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRemoveProbeBatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRemoveProbeBatch(IPL._IPLSimulator_t simulator, IPL._IPLProbeBatch_t probeBatch);
        
        /// <summary>
        /// Specifies simulation parameters that are not associated with any particular source.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <param name="flags">The types of simulation for which to specify shared inputs. If, for example, direct
        /// and reflections simulations are being run on separate threads, you can call this
        /// function on the direct simulation thread with @c IPL_SIMULATIONFLAGS_DIRECT, and on the
        /// reflections simulation thread with @c IPL_SIMULATIONFLAGS_REFLECTIONS, without requiring
        /// any synchronization between the calls.</param>
        /// <param name="sharedInputs">The shared input parameters to set.</param>
        [DllImport(Library, EntryPoint = "iplSimulatorSetSharedInputs", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorSetSharedInputs(IPL._IPLSimulator_t simulator, IPL.SimulationFlags flags, ref IPL.SimulationSharedInputs sharedInputs);
        
        /// <summary>
        /// Commits changes to the scene or probe batches used for simulation.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// Call this function after calling @c iplSimulatorSetScene, @c iplSimulatorAddProbeBatch, or 
        /// @c iplSimulatorRemoveProbeBatch for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorCommit", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorCommit(IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Runs a direct simulation for all sources added to the simulator. This may include distance attenuation,
        /// air absorption, directivity, occlusion, and transmission.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// This function should not be called from the audio processing thread if occlusion and/or transmission
        /// are enabled.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRunDirect", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRunDirect(IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Runs a reflections simulation for all sources added to the simulator.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// This function can be CPU intensive, and should be called from a separate thread in order to not
        /// block either the audio processing thread or the game's main update thread.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRunReflections", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRunReflections(IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Runs a pathing simulation for all sources added to the simulator.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// This function can be CPU intensive, and should be called from a separate thread in order to not
        /// block either the audio processing thread or the game's main update thread.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRunPathing", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRunPathing(IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Creates a simulation source.
        /// </summary>
        /// <param name="simulator">The simulator with which this source will be used.</param>
        /// <param name="settings">The settings to use for creating the source.</param>
        /// <param name="source">[out] The created source.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSourceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SourceCreate(IPL._IPLSimulator_t simulator, ref IPL.SourceSettings settings, out IPL._IPLSource_t source);
        
        /// <summary>
        /// Retains an additional reference to a source.
        /// </summary>
        /// <param name="source">The source to retain a reference to.</param>
        /// <returns>The additional reference to the source.</returns>
        [DllImport(Library, EntryPoint = "iplSourceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL._IPLSource_t SourceRetain(IPL._IPLSource_t source);
        
        /// <summary>
        /// Releases a reference to a source.
        /// </summary>
        /// <param name="source">The source to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSourceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceRelease(ref IPL._IPLSource_t source);
        
        /// <summary>
        /// Adds a source to the set of sources processed by a simulator in subsequent simulations.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <param name="source">The source to add.</param>
        [DllImport(Library, EntryPoint = "iplSourceAdd", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceAdd(IPL._IPLSource_t source, IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Removes a source from the set of sources processed by a simulator in subsequent simulations.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <param name="source">The source to remove.</param>
        [DllImport(Library, EntryPoint = "iplSourceRemove", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceRemove(IPL._IPLSource_t source, IPL._IPLSimulator_t simulator);
        
        /// <summary>
        /// Specifies simulation parameters for a source.
        /// </summary>
        /// <param name="source">The source to specify parameters for.</param>
        /// <param name="flags">The types of simulation for which to specify inputs. If, for example, direct
        /// and reflections simulations are being run on separate threads, you can call this
        /// function on the direct simulation thread with @c IPL_SIMULATIONFLAGS_DIRECT, and on the
        /// reflections simulation thread with @c IPL_SIMULATIONFLAGS_REFLECTIONS, without requiring
        /// any synchronization between the calls.</param>
        /// <param name="inputs">The input parameters to set.</param>
        [DllImport(Library, EntryPoint = "iplSourceSetInputs", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceSetInputs(IPL._IPLSource_t source, IPL.SimulationFlags flags, ref IPL.SimulationInputs inputs);
        
        /// <summary>
        /// Retrieves simulation results for a source.
        /// </summary>
        /// <param name="source">The source to retrieve results for.</param>
        /// <param name="flags">The types of simulation for which to retrieve results.</param>
        /// <param name="outputs">[out] The simulation results.</param>
        [DllImport(Library, EntryPoint = "iplSourceGetOutputs", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceGetOutputs(IPL._IPLSource_t source, IPL.SimulationFlags flags, out IPL.SimulationOutputs outputs);
        
        /// <summary>
        /// Calculates the distance attenuation between a source and a listener.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="source">The position of the source.</param>
        /// <param name="listener">The position of the listener.</param>
        /// <param name="model">The distance attenuation model to use.</param>
        /// <returns>The distance attenuation to apply, between @c 0 and @c 1.</returns>
        [DllImport(Library, EntryPoint = "iplDistanceAttenuationCalculate", CallingConvention = CallingConvention.Cdecl)]
        public static extern float DistanceAttenuationCalculate(IPL._IPLContext_t context, IPL.Vector3 source, IPL.Vector3 listener, ref IPL.DistanceAttenuationModel model);
        
        /// <summary>
        /// Calculates the air absorption coefficients between a source and a listener.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="source">The position of the source.</param>
        /// <param name="listener">The position of the listener.</param>
        /// <param name="model">The air absorption model to use.</param>
        /// <param name="airAbsorption">[out] The 3-band air absorption coefficients, each between @c 0 and @c 1.</param>
        [DllImport(Library, EntryPoint = "iplAirAbsorptionCalculate", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AirAbsorptionCalculate(IPL._IPLContext_t context, IPL.Vector3 source, IPL.Vector3 listener, ref IPL.AirAbsorptionModel model, out float airAbsorption);
        
        /// <summary>
        /// Calculates the attenuation of a source due to its directivity pattern and orientation relative to a listener.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="source">The position and orientation of the source.</param>
        /// <param name="listener">The position of the listener.</param>
        /// <param name="model">The directivity pattern to use.</param>
        /// <returns>The directivity value to apply, between @c 0 and @c 1.</returns>
        [DllImport(Library, EntryPoint = "iplDirectivityCalculate", CallingConvention = CallingConvention.Cdecl)]
        public static extern float DirectivityCalculate(IPL._IPLContext_t context, IPL.CoordinateSpace3 source, IPL.Vector3 listener, ref IPL.Directivity model);
    }
}
