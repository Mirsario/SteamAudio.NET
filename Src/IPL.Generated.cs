//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace SteamAudio
{
    using System.Runtime.InteropServices;
    
    public static partial class IPL
    {
        /// <summary>
        /// Status codes returned by Steam Audio API functions.
        /// </summary>
        public enum Error : int
        {
            /// <summary>
            /// The operation completed successfully.
            /// </summary>
            Success,
            
            /// <summary>
            /// An unspecified error occurred.
            /// </summary>
            Failure,
            
            /// <summary>
            /// The system ran out of memory.
            /// </summary>
            OutOfMemory,
            
            /// <summary>
            /// An error occurred while initializing an external dependency.
            /// </summary>
            Initialization,
        }
        
        /// <summary>
        /// Severity levels of log messages generated by Steam Audio.
        /// </summary>
        public enum LogLevel : int
        {
            /// <summary>
            /// A normal, informational message.
            /// </summary>
            Info,
            
            /// <summary>
            /// A warning. The operation that generated this message may not work as expected.
            /// </summary>
            Warning,
            
            /// <summary>
            /// An error. The operation that generated this message failed.
            /// </summary>
            Error,
            
            /// <summary>
            /// A detailed message intended for debugging purposes only.
            /// </summary>
            Debug,
        }
        
        /// <summary>
        /// SIMD instruction sets that Steam Audio can attempt to use.
        /// </summary>
        public enum SimdLevel : int
        {
            /// <summary>
            /// Intel Streaming SIMD Extensions 2. Up to 4 simultaneous floating-point operations.
            /// </summary>
            Sse2,
            
            /// <summary>
            /// Intel Streaming SIMD Extensions 4.2 or older. Up to 4 simultaneous floating-point operations.
            /// </summary>
            Sse4,
            
            /// <summary>
            /// Intel Advanced Vector Extensions or older. Up to 8 simultaneous floating-point operations.
            /// </summary>
            Avx,
            
            /// <summary>
            /// Intel Advanced Vector Extensions 2 or older. Up to 8 simultaneous floating-point operations.
            /// </summary>
            Avx2,
            
            /// <summary>
            /// Intel Advanced Vector Extensions 512 or older. Up to 16 simultaneous floating-point operations.
            /// </summary>
            Avx512,
            
            /// <summary>
            /// ARM NEON. Up to 4 simultaneous floating-point operations.
            /// </summary>
            Neon = Sse2,
        }
        
        /// <summary>
        /// The type of devices to include when listing OpenCL devices.
        /// </summary>
        public enum OpenCLDeviceType : int
        {
            /// <summary>
            /// List both CPU and GPU devices.
            /// </summary>
            Any,
            
            /// <summary>
            /// Only list CPU devices.
            /// </summary>
            Cpu,
            
            /// <summary>
            /// Only list GPU devices.
            /// </summary>
            Gpu,
        }
        
        /// <summary>
        /// The types of scenes that can be created. Each scene type corresponds to a different ray tracing
        /// implementation.
        /// </summary>
        public enum SceneType : int
        {
            /// <summary>
            /// Steam Audio's built-in ray tracer. Supports multi-threading. Runs on all platforms that Steam Audio
            /// supports.
            /// </summary>
            Default,
            
            /// <summary>
            /// The Intel Embree ray tracer. Supports multi-threading. This is a highly optimized implementation, and
            /// is likely to be faster than the Phonon ray tracer. However, Embree requires Windows, Linux, or macOS,
            /// and a 32-bit x86 or 64-bit x86_64 CPU.
            /// </summary>
            Embree,
            
            /// <summary>
            /// The AMD Radeon Rays ray tracer. This is an OpenCL implementation, and can use either the CPU or any
            /// GPU that supports OpenCL 1.2 or later. If using the GPU, it is likely to be significantly faster than
            /// the Phonon ray tracer. However, with heavy real-time simulation workloads, it may impact your
            /// application's frame rate. On supported AMD GPUs, you can use the Resource Reservation feature to
            /// mitigate this issue.
            /// </summary>
            RadeonRays,
            
            /// <summary>
            /// Allows you to specify callbacks to your own ray tracer. Useful if your application already uses a 
            /// high-performance ray tracer. This option uses the least amount of memory at run-time, since it does 
            /// not have to build any ray tracing data structures of its own.
            /// </summary>
            Custom,
        }
        
        /// <summary>
        /// Supported speaker layouts.
        /// </summary>
        public enum SpeakerLayoutType : int
        {
            /// <summary>
            /// Mono.
            /// </summary>
            Mono,
            
            /// <summary>
            /// Stereo (left, right).
            /// </summary>
            Stereo,
            
            /// <summary>
            /// Front left, front right, rear left, rear right.
            /// </summary>
            Quadraphonic,
            
            /// <summary>
            /// Front left, front right, front center, LFE, rear left, rear right.
            /// </summary>
            Surround51,
            
            /// <summary>
            /// Front left, front right, front center, LFE, rear left, rear right, side left, side right.
            /// </summary>
            Surround71,
            
            /// <summary>
            /// User-defined speaker layout. See @c IPLSpeakerLayout.
            /// </summary>
            Custom,
        }
        
        /// <summary>
        /// Supported channel ordering and normalization schemes for Ambisonic audio.
        /// </summary>
        public enum AmbisonicsType : int
        {
            /// <summary>
            /// ACN channel ordering, orthonormal spherical harmonics.
            /// </summary>
            N3D,
            
            /// <summary>
            /// ACN channel ordering, semi-normalized spherical harmonics. AmbiX format.
            /// </summary>
            Sn3d,
            
            /// <summary>
            /// Furse-Malham (B-format).
            /// </summary>
            Fuma,
        }
        
        /// <summary>
        /// States that an audio effect can be left in after processing a frame of audio.
        /// </summary>
        public enum AudioEffectState : int
        {
            /// <summary>
            /// One or more samples of tail remain in the effect's internal buffers.
            /// </summary>
            TailRemaining,
            
            /// <summary>
            /// No tail remains in the effect's internal buffers.
            /// </summary>
            TailComplete,
        }
        
        /// <summary>
        /// The type of HRTF to use.
        /// </summary>
        public enum HrtfType : int
        {
            /// <summary>
            /// The built-in HRTF.
            /// </summary>
            Default,
            
            /// <summary>
            /// An HRTF loaded from a SOFA file.
            /// </summary>
            Sofa,
        }
        
        /// <summary>
        /// Techniques for interpolating HRTF data. This is used when rendering a point source whose position relative to
        /// the listener is not contained in the measured HRTF data.
        /// </summary>
        public enum HrtfInterpolation : int
        {
            /// <summary>
            /// Nearest-neighbor filtering, i.e., no interpolation. Selects the measurement location that is closest to 
            /// the source's actual location.
            /// </summary>
            Nearest,
            
            /// <summary>
            /// Bilinear filtering. Incurs a relatively high CPU overhead as compared to nearest-neighbor filtering, so use 
            /// this for sounds where it has a significant benefit. Typically, bilinear filtering is most useful for wide-band 
            /// noise-like sounds, such as radio static, mechanical noise, fire, etc.
            /// </summary>
            Bilinear,
        }
        
        /// <summary>
        /// Flags indicating which direct path parameters to apply.
        /// </summary>
        [Flags]
        public enum DirectEffectFlags : int
        {
            /// <summary>
            /// Apply frequency-independent distance attenuation.
            /// </summary>
            ApplyDistanceAttenuation = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Apply frequency-dependent air absorption as a function of distance.
            /// </summary>
            ApplyAirAbsorption = unchecked((int)1  << (int) 1),
            
            /// <summary>
            /// Apply attenuation due to source directivity pattern.
            /// </summary>
            ApplyDirectivity = unchecked((int)1  << (int) 2),
            
            /// <summary>
            /// Apply occlusion.
            /// </summary>
            ApplyOcclusion = unchecked((int)1  << (int) 3),
            
            /// <summary>
            /// Apply transmission along with occlusion.
            /// </summary>
            ApplyTransmission = unchecked((int)1  << (int) 4),
        }
        
        /// <summary>
        /// Modes of applying transmission effects.
        /// </summary>
        public enum TransmissionType : int
        {
            /// <summary>
            /// Transmission is frequency-independent.
            /// </summary>
            FrequencyIndependent,
            
            /// <summary>
            /// Transmission is frequency-dependent.
            /// </summary>
            FrequencyDependent,
        }
        
        /// <summary>
        /// Type of reflection effect algorithm to use.
        /// </summary>
        public enum ReflectionEffectType : int
        {
            /// <summary>
            /// Multi-channel convolution reverb. Reflections reaching the listener are encoded in an Impulse Response (IR),
            /// which is a filter that records each reflection as it arrives. This algorithm renders reflections with the most
            /// detail, but may result in significant CPU usage. Using a reflection mixer with this algorithm provides a
            /// reduction in CPU usage.
            /// </summary>
            Convolution,
            
            /// <summary>
            /// Parametric (or artificial) reverb, using feedback delay networks. The reflected sound field is reduced to a few
            /// numbers that describe how reflected energy decays over time. This is then used to drive an approximate model
            /// of reverberation in an indoor space. This algorithm results in lower CPU usage, but cannot render individual
            /// echoes, especially in outdoor spaces. A reflection mixer cannot be used with this algorithm.
            /// </summary>
            Parametric,
            
            /// <summary>
            /// A hybrid of convolution and parametric reverb. The initial portion of the IR is rendered using convolution
            /// reverb, but the later part is used to estimate a parametric reverb. The point in the IR where this transition
            /// occurs can be controlled. This algorithm allows a trade-off between rendering quality and CPU usage. An
            /// reflection mixer cannot be used with this algorithm.
            /// </summary>
            Hybrid,
            
            /// <summary>
            /// Multi-channel convolution reverb, using AMD TrueAudio Next for GPU acceleration. This algorithm is similar
            /// to @c IPL_REFLECTIONEFFECTYPE_CONVOLUTION, but uses the GPU instead of the CPU for processing, allowing
            /// significantly more sources to be processed. A reflection mixer must be used with this algorithm, because
            /// the GPU will process convolution reverb at a single point in your audio processing pipeline.
            /// </summary>
            Tan,
        }
        
        /// <summary>
        /// The different algorithms for generating probes.
        /// </summary>
        public enum ProbeGenerationType : int
        {
            /// <summary>
            /// Generates a single probe at the center of the specified box.
            /// </summary>
            Centroid,
            
            /// <summary>
            /// Generates probes that are uniformly-spaced, at a fixed height above solid geometry. A probe will never be 
            /// generated above another probe unless there is a solid object between them. The goal is to model floors or 
            /// terrain, and generate probes that are a fixed height above the floor or terrain, and uniformly-spaced along 
            /// the horizontal plane. This algorithm is not suitable for scenarios where the listener may fly into a region 
            /// with no probes; if this happens, the listener will not be influenced by any of the baked data.
            /// </summary>
            UniformFloor,
        }
        
        /// <summary>
        /// The different ways in which the source and listener positions used to generate baked data can vary as a function
        /// of probe position.
        /// </summary>
        public enum BakedDataVariation : int
        {
            /// <summary>
            /// At each probe, baked data is calculated with both the source and the listener at the probe position. This
            /// is useful for modeling traditional reverbs, which depend only on the listener's position (or only on the
            /// source's position).
            /// </summary>
            Reverb,
            
            /// <summary>
            /// At each probe, baked data is calculated with the source at some fixed position (specified separately),
            /// and the listener at the probe position. This is used for modeling reflections from a static source to any
            /// point within the probe batch.
            /// </summary>
            StaticSource,
            
            /// <summary>
            /// At each probe, baked data is calculated with the source at the probe position, and the listener at some
            /// fixed position (specified separately). This is used for modeling reflections from a moving source to a
            /// static listener.
            /// </summary>
            StaticListener,
            
            /// <summary>
            /// Baked data is calculated for each pair of probes. For example, this is used for calculating paths between
            /// every pair of probes in a batch.
            /// </summary>
            Dynamic,
        }
        
        /// <summary>
        /// The types of baked data that can be stored in a probe batch.
        /// </summary>
        public enum BakedDataType : int
        {
            /// <summary>
            /// Reflections. The source and listener positions used to compute the reflections data stored at each probe
            /// depends on the @c IPLBakedDataVariation selected.
            /// </summary>
            Reflections,
            
            /// <summary>
            /// Pathing. The probe batch stores data about the shortest paths between any pair of probes in the batch.
            /// </summary>
            Pathing,
        }
        
        /// <summary>
        /// Flags for specifying what types of reflections data to bake.
        /// </summary>
        [Flags]
        public enum ReflectionsBakeFlags : int
        {
            /// <summary>
            /// Bake impulse responses for @c IPL_REFLECTIONEFFECTTYPE_CONVOLUTION, @c IPL_REFLECTIONEFFECTTYPE_HYBRID, or @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            BakeConvolution = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Bake parametric reverb for @c IPL_REFLECTIONEFFECTTYPE_PARAMETRIC or @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            BakeParametric = unchecked((int)1  << (int) 1),
        }
        
        /// <summary>
        /// Flags indicating which types of simulation should be enabled for a given @c IPLSource.
        /// </summary>
        [Flags]
        public enum SimulationFlags : int
        {
            /// <summary>
            /// Enable direct simulation. This includes distance attenuation, air absorption, directivity, occlusion, and
            /// transmission.
            /// </summary>
            Direct = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Enable reflections simulation. This includes both real-time and baked simulation.
            /// </summary>
            Reflections = unchecked((int)1  << (int) 1),
            
            /// <summary>
            /// Enable pathing simulation.
            /// </summary>
            Pathing = unchecked((int)1  << (int) 2),
        }
        
        /// <summary>
        /// Flags indicating which types of direct simulation should be enabled for a given @c IPLSource.
        /// </summary>
        [Flags]
        public enum DirectSimulationFlags : int
        {
            /// <summary>
            /// Enable distance attenuation calculations.
            /// </summary>
            DistanceAttenuation = unchecked((int)1  << (int) 0),
            
            /// <summary>
            /// Enable air absorption calculations.
            /// </summary>
            AirAbsorption = unchecked((int)1  << (int) 1),
            
            /// <summary>
            /// Enable directivity calculations.
            /// </summary>
            Directivity = unchecked((int)1  << (int) 2),
            
            /// <summary>
            /// Enable occlusion simulation.
            /// </summary>
            Occlusion = unchecked((int)1  << (int) 3),
            
            /// <summary>
            /// Enable transmission simulation. Requires occlusion to also be enabled.
            /// </summary>
            Transmission = unchecked((int)1  << (int) 4),
        }
        
        /// <summary>
        /// The types of distance attenuation that can be used.
        /// </summary>
        public enum DistanceAttenuationModelType : int
        {
            /// <summary>
            /// The default distance attenuation model. This is an inverse distance falloff, with all sounds within 1 meter 
            /// of the listener rendered without distance attenuation.
            /// </summary>
            Default,
            
            /// <summary>
            /// An inverse distance falloff. You can configure the minimum distance, within which distance attenuation is not
            /// applied.
            /// </summary>
            InverseDistance,
            
            /// <summary>
            /// An arbitrary distance falloff function, defined by a callback function.
            /// </summary>
            Callback,
        }
        
        /// <summary>
        /// The types of air absorption that can be used.
        /// </summary>
        public enum AirAbsorptionModelType : int
        {
            /// <summary>
            /// The default air absorption model. This is an exponential falloff, with decay rates derived from physical
            /// properties of air.
            /// </summary>
            Default,
            
            /// <summary>
            /// An exponential falloff. You can configure the decay rates for each frequency band.
            /// </summary>
            Exponential,
            
            /// <summary>
            /// An arbitrary air absorption model, defined by a callback function.
            /// </summary>
            Callback,
        }
        
        /// <summary>
        /// The different algorithms for simulating occlusion.
        /// </summary>
        public enum OcclusionType : int
        {
            /// <summary>
            /// Raycast occlusion. A single ray is traced from the listener to the source. If the ray hits a solid object
            /// before it reaches the source, the source is considered occluded.
            /// </summary>
            Raycast,
            
            /// <summary>
            /// A volumetric occlusion algorithm that can model partial occlusion. The source is modeled as a sphere with
            /// a configurable radius. Multiple points are sampled within the volume of this sphere. Rays are then traced
            /// from each sample point to both the source and the listener. A sample point is considered occluded if either
            /// of these two rays is occluded. The occlusion value for the source is calculated as the fraction of
            /// sample points that are unoccluded. This algorithm allows for smoother transitions in and out of occlusion.
            /// </summary>
            Volumetric,
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Context : IEquatable<Context>
        {
            private readonly IntPtr _handle;
            
            public Context(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(Context other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is Context other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(Context left, Context right) => left.Equals(right);
            
            public static bool operator !=(Context left, Context right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a context object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ContextSettings
        {
            /// <summary>
            /// The API version used by the caller. Context creation will fail if `phonon.dll` does not implement a
            /// compatible version of the API. Typically, this should be set to `STEAMAUDIO_VERSION`.
            /// </summary>
            public uint Version;
            
            /// <summary>
            /// (Optional) If non-NULL, Steam Audio will call this function to record log messages generated by
            /// certain operations.
            /// </summary>
            public IPL.LogFunction LogCallback;
            
            /// <summary>
            /// (Optional) If non-NULL, Steam Audio will call this function whenever it needs to allocate
            /// memory.
            /// </summary>
            public IPL.AllocateFunction AllocateCallback;
            
            /// <summary>
            /// (Optional) If non-NULL, Steam Audio will call this function whenever it needs to free memory.
            /// </summary>
            public IPL.FreeFunction FreeCallback;
            
            /// <summary>
            /// The maximum SIMD instruction set level that Steam Audio should use. Steam Audio automatically
            /// chooses the best instruction set to use based on the user's CPU, but you can prevent it from
            /// using certain newer instruction sets using this parameter. For example, with some workloads,
            /// AVX512 instructions consume enough power that the CPU clock speed will be throttled, resulting
            /// in lower performance than expected. If you observe this in your application, set this
            /// parameter to `IPL_SIMDLEVEL_AVX2` or lower.
            /// </summary>
            public IPL.SimdLevel SimdLevel;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void LogFunction(IPL.LogLevel level, [MarshalAs(UnmanagedType.LPStr)] string message);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr AllocateFunction(ulong size, ulong alignment);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FreeFunction(IntPtr memoryBlock);
        
        /// <summary>
        /// A point or vector in 3D space. Steam Audio uses a right-handed coordinate system, with the positive x-axis pointing
        /// right, the positive y-axis pointing up, and the negative z-axis pointing ahead. Position and direction data
        /// obtained from a game engine or audio engine must be properly transformed before being passed to any Steam Audio API
        /// function.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Vector3
        {
            /// <summary>
            /// The x-coordinate.
            /// </summary>
            public float X;
            
            /// <summary>
            /// The y-coordinate.
            /// </summary>
            public float Y;
            
            /// <summary>
            /// The z-coordinate.
            /// </summary>
            public float Z;
        }
        
        /// <summary>
        /// A 4x4 matrix used to represent an affine transform.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Matrix4x4
        {
            /// <summary>
            /// Matrix elements, in row-major order.
            /// </summary>
            public fixed float Elements[16];
        }
        
        /// <summary>
        /// An axis-aligned box. Axis-aligned boxes are used to specify a volume of 3D space.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Box
        {
            /// <summary>
            /// The minimum coordinates of any vertex.
            /// </summary>
            public IPL.Vector3 MinCoordinates;
            
            /// <summary>
            /// The maximum coordinates of any vertex.
            /// </summary>
            public IPL.Vector3 MaxCoordinates;
        }
        
        /// <summary>
        /// A sphere. Spheres are used to define a region of influence around a point.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Sphere
        {
            /// <summary>
            /// The center.
            /// </summary>
            public IPL.Vector3 Center;
            
            /// <summary>
            /// The radius.
            /// </summary>
            public float Radius;
        }
        
        /// <summary>
        /// A 3D coordinate system, expressed relative to a canonical coordinate system.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct CoordinateSpace3
        {
            /// <summary>
            /// Unit vector pointing to the right (local +x axis).
            /// </summary>
            public IPL.Vector3 Right;
            
            /// <summary>
            /// Unit vector pointing upwards (local +y axis).
            /// </summary>
            public IPL.Vector3 Up;
            
            /// <summary>
            /// Unit vector pointing forwards (local -z axis).
            /// </summary>
            public IPL.Vector3 Ahead;
            
            /// <summary>
            /// The origin, relative to the canonical coordinate system.
            /// </summary>
            public IPL.Vector3 Origin;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SerializedObject : IEquatable<SerializedObject>
        {
            private readonly IntPtr _handle;
            
            public SerializedObject(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SerializedObject other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SerializedObject other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SerializedObject left, SerializedObject right) => left.Equals(right);
            
            public static bool operator !=(SerializedObject left, SerializedObject right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a serialized object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SerializedObjectSettings
        {
            /// <summary>
            /// If non-NULL, the serialized object will contain the data in this buffer. If NULL,
            /// the serialized object will start out empty.
            /// </summary>
            public IntPtr Data;
            
            /// <summary>
            /// The number of bytes in the buffer pointed to by @c data. Set to 0 if @c data is 
            /// NULL.
            /// </summary>
            public ulong Size;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct EmbreeDevice : IEquatable<EmbreeDevice>
        {
            private readonly IntPtr _handle;
            
            public EmbreeDevice(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(EmbreeDevice other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is EmbreeDevice other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(EmbreeDevice left, EmbreeDevice right) => left.Equals(right);
            
            public static bool operator !=(EmbreeDevice left, EmbreeDevice right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct EmbreeDeviceSettings
        {
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct OpenCLDeviceList : IEquatable<OpenCLDeviceList>
        {
            private readonly IntPtr _handle;
            
            public OpenCLDeviceList(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(OpenCLDeviceList other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is OpenCLDeviceList other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(OpenCLDeviceList left, OpenCLDeviceList right) => left.Equals(right);
            
            public static bool operator !=(OpenCLDeviceList left, OpenCLDeviceList right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct OpenCLDevice : IEquatable<OpenCLDevice>
        {
            private readonly IntPtr _handle;
            
            public OpenCLDevice(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(OpenCLDevice other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is OpenCLDevice other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(OpenCLDevice left, OpenCLDevice right) => left.Equals(right);
            
            public static bool operator !=(OpenCLDevice left, OpenCLDevice right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Specifies requirements that an OpenCL device must meet in order to be considered when listing
        /// OpenCL devices.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct OpenCLDeviceSettings
        {
            /// <summary>
            /// The type of device. Set to @c IPL_OPENCLDEVICETYPE_ANY to consider all available devices.
            /// </summary>
            public IPL.OpenCLDeviceType Type;
            
            /// <summary>
            /// The number of GPU compute units (CUs) that should be reserved for use by Steam Audio. If set to a
            /// non-zero value, then a GPU will be included in the device list only if it can reserve at least
            /// this many CUs. Set to 0 to indicate that Steam Audio can use the entire GPU, in which case all
            /// available GPUs will be considered.
            /// </summary>
            /// <remarks>
            /// Ignored if @c type is @c IPL_OPENCLDEVICETYPE_CPU.
            /// </remarks>
            public int NumCUsToReserve;
            
            /// <summary>
            /// The fraction of reserved CUs that should be used for impulse response (IR) update. IR update
            /// includes: a) ray tracing using Radeon Rays to simulate sound propagation, and/or b) pre-transformation
            /// of IRs for convolution using TrueAudio Next. Steam Audio will only list GPU devices that are able
            /// to subdivide the reserved CUs as per this value. The value must be between 0 and 1.
            /// </summary>
            /// <remarks>
            /// For example, if @c numCUsToReserve is @c 8, and @c fractionCUsForIRUpdate is @c 0.5f, then 4 CUs
            /// will be used for IR update and 4 CUs will be used for convolution. Below are typical scenarios:-   Using only TrueAudio Next. Set @c fractionCUsForIRUpdate to @c 0.5f. This ensures that reserved
            /// CUs are available for IR update as well as convolution.-   Using TrueAudio Next and Radeon Rays for real-time simulation and rendering. Choosing
            /// @c fractionCUsForIRUpdate may require some experimentation to utilize reserved CUs optimally. You
            /// can start by setting @c fractionCUsForIRUpdate to @c 0.5f. However, if IR calculation has high
            /// latency with these settings, increase @c fractionCUsForIRUpdate to use more CUs for ray tracing.-   Using only Radeon Rays. Set @c fractionCUsForIRUpdate to @c 1, to make sure all the reserved CUs
            /// are used for ray tracing. If using Steam Audio for preprocessing (e.g. baking reverb), then
            /// consider setting @c numCUsToReserve to @c 0 to use the entire GPU for accelerated ray tracing.Ignored if @c type is @c IPL_OPENCLDEVICETYPE_CPU or @c numCUsToReserve is @c 0.
            /// </remarks>
            public float FractionCUsForIRUpdate;
            
            /// <summary>
            /// If @c IPL_TRUE, then the GPU device must support TrueAudio Next. It is not necessary to set this
            /// to @c IPL_TRUE if @c numCUsToReserve or @c fractionCUsForIRUpdate are set to non-zero values.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool RequiresTAN;
        }
        
        /// <summary>
        /// Describes the properties of an OpenCL device. This information can be used to select the most suitable
        /// device for your application.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct OpenCLDeviceDesc
        {
            /// <summary>
            /// The OpenCL platform id. Can be cast to @c cl_platform_id.
            /// </summary>
            public IntPtr Platform;
            
            /// <summary>
            /// The OpenCL platform name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string PlatformName;
            
            /// <summary>
            /// The OpenCL platform vendor's name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string PlatformVendor;
            
            /// <summary>
            /// The OpenCL platform version.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string PlatformVersion;
            
            /// <summary>
            /// The OpenCL device id. Can be cast to @c cl_device_id.
            /// </summary>
            public IntPtr Device;
            
            /// <summary>
            /// The OpenCL device name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string DeviceName;
            
            /// <summary>
            /// The OpenCL device vendor's name.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string DeviceVendor;
            
            /// <summary>
            /// The OpenCL device version.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string DeviceVersion;
            
            /// <summary>
            /// The type of OpenCL device.
            /// </summary>
            public IPL.OpenCLDeviceType Type;
            
            /// <summary>
            /// The number of CUs reserved for convolution. May be @c 0 if CU reservation is not supported.
            /// </summary>
            public int NumConvolutionCUs;
            
            /// <summary>
            /// The number of CUs reserved for IR update. May be @c 0 if CU reservation is not supported.
            /// </summary>
            public int NumIRUpdateCUs;
            
            /// <summary>
            /// The CU reservation granularity. CUs can only be reserved on this device in multiples of this number.
            /// </summary>
            public int Granularity;
            
            /// <summary>
            /// A relative performance score of a single CU of this device. Only applicable to supported AMD GPUs.
            /// </summary>
            public float PerfScore;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct RadeonRaysDevice : IEquatable<RadeonRaysDevice>
        {
            private readonly IntPtr _handle;
            
            public RadeonRaysDevice(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(RadeonRaysDevice other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is RadeonRaysDevice other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(RadeonRaysDevice left, RadeonRaysDevice right) => left.Equals(right);
            
            public static bool operator !=(RadeonRaysDevice left, RadeonRaysDevice right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct RadeonRaysDeviceSettings
        {
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct TrueAudioNextDevice : IEquatable<TrueAudioNextDevice>
        {
            private readonly IntPtr _handle;
            
            public TrueAudioNextDevice(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(TrueAudioNextDevice other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is TrueAudioNextDevice other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(TrueAudioNextDevice left, TrueAudioNextDevice right) => left.Equals(right);
            
            public static bool operator !=(TrueAudioNextDevice left, TrueAudioNextDevice right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a TrueAudio Next device.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct TrueAudioNextDeviceSettings
        {
            /// <summary>
            /// The number of samples in an audio frame.
            /// </summary>
            public int FrameSize;
            
            /// <summary>
            /// The number of samples in the impulse responses that will be used for convolution.
            /// </summary>
            public int IrSize;
            
            /// <summary>
            /// The Ambisonic order of the impulse responses that will be used for convolution.
            /// </summary>
            public int Order;
            
            /// <summary>
            /// The maximum number of sources that will use TrueAudio Next for convolution.
            /// </summary>
            public int MaxSources;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Scene : IEquatable<Scene>
        {
            private readonly IntPtr _handle;
            
            public Scene(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(Scene other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is Scene other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(Scene left, Scene right) => left.Equals(right);
            
            public static bool operator !=(Scene left, Scene right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct StaticMesh : IEquatable<StaticMesh>
        {
            private readonly IntPtr _handle;
            
            public StaticMesh(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(StaticMesh other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is StaticMesh other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(StaticMesh left, StaticMesh right) => left.Equals(right);
            
            public static bool operator !=(StaticMesh left, StaticMesh right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct InstancedMesh : IEquatable<InstancedMesh>
        {
            private readonly IntPtr _handle;
            
            public InstancedMesh(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(InstancedMesh other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is InstancedMesh other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(InstancedMesh left, InstancedMesh right) => left.Equals(right);
            
            public static bool operator !=(InstancedMesh left, InstancedMesh right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A triangle in 3D space.
        /// </summary>
        /// <remarks>
        /// Triangles are specified by their three vertices, which are in turn specified using indices into a 
        /// vertex array.Steam Audio uses a counter-clockwise winding order. This means that when looking at the triangle such that the 
        /// normal is pointing towards you, the vertices are specified in counter-clockwise order.Each triangle must be specified using three vertices; triangle strip or fan representations are 
        /// not supported.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Triangle
        {
            /// <summary>
            /// Indices of the three vertices of this triangle.
            /// </summary>
            public fixed int Indices[3];
        }
        
        /// <summary>
        /// The acoustic properties of a surface.
        /// </summary>
        /// <remarks>
        /// You can specify the acoustic material properties of each triangle, although typically many triangles will 
        /// share a common material.The acoustic material properties are specified for three frequency bands with center frequencies of 
        /// 400 Hz, 2.5 KHz, and 15 KHz.Below are the acoustic material properties for a few standard materials.```cpp
        /// {"generic",{0.10f,0.20f,0.30f,0.05f,0.100f,0.050f,0.030f}}
        /// {"brick",{0.03f,0.04f,0.07f,0.05f,0.015f,0.015f,0.015f}}
        /// {"concrete",{0.05f,0.07f,0.08f,0.05f,0.015f,0.002f,0.001f}}
        /// {"ceramic",{0.01f,0.02f,0.02f,0.05f,0.060f,0.044f,0.011f}}
        /// {"gravel",{0.60f,0.70f,0.80f,0.05f,0.031f,0.012f,0.008f}},
        /// {"carpet",{0.24f,0.69f,0.73f,0.05f,0.020f,0.005f,0.003f}}
        /// {"glass",{0.06f,0.03f,0.02f,0.05f,0.060f,0.044f,0.011f}}
        /// {"plaster",{0.12f,0.06f,0.04f,0.05f,0.056f,0.056f,0.004f}}
        /// {"wood",{0.11f,0.07f,0.06f,0.05f,0.070f,0.014f,0.005f}}
        /// {"metal",{0.20f,0.07f,0.06f,0.05f,0.200f,0.025f,0.010f}}
        /// {"rock",{0.13f,0.20f,0.24f,0.05f,0.015f,0.002f,0.001f}}
        /// ```
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Material
        {
            /// <summary>
            /// Fraction of sound energy absorbed at low, middle, high frequencies. Between 0.0 and 1.0.
            /// </summary>
            public fixed float Absorption[3];
            
            /// <summary>
            /// Fraction of sound energy scattered in a random direction on reflection. Between 0.0 (pure specular) and 1.0 
            /// (pure diffuse).
            /// </summary>
            public float Scattering;
            
            /// <summary>
            /// Fraction of sound energy transmitted through at low, middle, high frequencies. Between 0.0 and 1.0. 
            /// Only used for direct occlusion calculations.
            /// </summary>
            public fixed float Transmission[3];
        }
        
        /// <summary>
        /// A ray in 3D space.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Ray
        {
            /// <summary>
            /// Origin of the ray.
            /// </summary>
            public IPL.Vector3 Origin;
            
            /// <summary>
            /// Unit vector direction of the ray.
            /// </summary>
            public IPL.Vector3 Direction;
        }
        
        /// <summary>
        /// Information about a ray's intersection with 3D geometry.
        /// </summary>
        /// <remarks>
        /// This information should be provided by ray tracer callbacks when using @c IPL_SCENETYPE_CUSTOM. Not all
        /// fields are required.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Hit
        {
            /// <summary>
            /// Distance along the ray from origin to hit point. Set to @c INFINITY if nothing was hit.
            /// </summary>
            public float Distance;
            
            /// <summary>
            /// (Optional) Index of the primitive hit by the ray. @c -1 if not provided.
            /// </summary>
            public int TriangleIndex;
            
            /// <summary>
            /// (Optional) Index of the scene object hit by the ray. @c -1 if not provided.
            /// </summary>
            public int ObjectIndex;
            
            /// <summary>
            /// (Optional) Index of the material associated with the primitive hit by the ray. @c -1 if not provided.
            /// </summary>
            public int MaterialIndex;
            
            /// <summary>
            /// Unit length surface normal at the hit point. Ignored if nothing was hit.
            /// </summary>
            public IPL.Vector3 Normal;
            
            /// <summary>
            /// Pointer to the material at the hit point. Ignored if nothing was hit.
            /// </summary>
            public IntPtr Material;
        }
        
        /// <summary>
        /// Settings used to create a scene.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SceneSettings
        {
            /// <summary>
            /// Type of scene to create.
            /// </summary>
            public IPL.SceneType Type;
            
            /// <summary>
            /// Callback for finding the closest hit along a ray. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.ClosestHitCallback ClosestHitCallback;
            
            /// <summary>
            /// Callback for finding whether a ray hits anything. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.AnyHitCallback AnyHitCallback;
            
            /// <summary>
            /// Callback for finding the closest hit along a batch of rays. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.BatchedClosestHitCallback BatchedClosestHitCallback;
            
            /// <summary>
            /// Callback for finding whether a batch of rays hits anything. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IPL.BatchedAnyHitCallback BatchedAnyHitCallback;
            
            /// <summary>
            /// Arbitrary user-provided data for use by ray tracing callbacks. Only for @c IPL_SCENETYPE_CUSTOM.
            /// </summary>
            public IntPtr UserData;
            
            /// <summary>
            /// Handle to an Embree device. Only for @c IPL_SCENETYPE_EMBREE.
            /// </summary>
            public IPL.EmbreeDevice EmbreeDevice;
            
            /// <summary>
            /// Handle to a Radeon Rays device. Only for @c IPL_SCENETYPE_RADEONRAYS.
            /// </summary>
            public IPL.RadeonRaysDevice RadeonRaysDevice;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void ClosestHitCallback(in IPL.Ray ray, float minDistance, float maxDistance, ref IPL.Hit hit, IntPtr userData);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void AnyHitCallback(in IPL.Ray ray, float minDistance, float maxDistance, ref byte occluded, IntPtr userData);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void BatchedClosestHitCallback(int numRays, in IPL.Ray rays, ref float minDistances, ref float maxDistances, ref IPL.Hit hits, IntPtr userData);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void BatchedAnyHitCallback(int numRays, in IPL.Ray rays, ref float minDistances, ref float maxDistances, ref byte occluded, IntPtr userData);
        
        /// <summary>
        /// Settings used to create a static mesh.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct StaticMeshSettings
        {
            /// <summary>
            /// Number of vertices.
            /// </summary>
            public int NumVertices;
            
            /// <summary>
            /// Number of triangles.
            /// </summary>
            public int NumTriangles;
            
            /// <summary>
            /// Number of materials.
            /// </summary>
            public int NumMaterials;
            
            /// <summary>
            /// Array containing vertices.
            /// </summary>
            public IntPtr Vertices;
            
            /// <summary>
            /// Array containing (indexed) triangles.
            /// </summary>
            public IntPtr Triangles;
            
            /// <summary>
            /// Array containing, for each triangle, the index of the associated material.
            /// </summary>
            public IntPtr MaterialIndices;
            
            /// <summary>
            /// Array of materials.
            /// </summary>
            public IntPtr Materials;
        }
        
        /// <summary>
        /// Settings used to create an instanced mesh.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct InstancedMeshSettings
        {
            /// <summary>
            /// Handle to the scene to be instantiated.
            /// </summary>
            public IPL.Scene SubScene;
            
            /// <summary>
            /// Local-to-world transform that places the instance within the parent scene.
            /// </summary>
            public IPL.Matrix4x4 Transform;
        }
        
        /// <summary>
        /// Describes a standard or custom speaker layout.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SpeakerLayout
        {
            /// <summary>
            /// See @c IPLSpeakerLayoutType.
            /// </summary>
            public IPL.SpeakerLayoutType Type;
            
            /// <summary>
            /// Number of speakers. Only for IPL_SPEAKERLAYOUTTYPE_CUSTOM.
            /// </summary>
            public int NumSpeakers;
            
            /// <summary>
            /// Array of unit-length directions for each speaker. Only for IPL_SPEAKERLAYOUTTYPE_CUSTOM.
            /// </summary>
            public IntPtr Speakers;
        }
        
        /// <summary>
        /// Global settings for audio signal processing.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AudioSettings
        {
            /// <summary>
            /// Sampling rate, in Hz.
            /// </summary>
            public int SamplingRate;
            
            /// <summary>
            /// Frame size, in samples. Independent of number of channels.
            /// </summary>
            public int FrameSize;
        }
        
        /// <summary>
        /// Describes an audio buffer. All audio buffers passed to Steam Audio must be deinterleaved.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AudioBuffer
        {
            /// <summary>
            /// Number of channels.
            /// </summary>
            public int NumChannels;
            
            /// <summary>
            /// Number of samples per channel.
            /// </summary>
            public int NumSamples;
            
            /// <summary>
            /// Array of pointers to sample data for each channel. Allocation of sample data is up to the user.
            /// </summary>
            public IntPtr Data;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Hrtf : IEquatable<Hrtf>
        {
            private readonly IntPtr _handle;
            
            public Hrtf(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(Hrtf other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is Hrtf other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(Hrtf left, Hrtf right) => left.Equals(right);
            
            public static bool operator !=(Hrtf left, Hrtf right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an HRTF object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct HrtfSettings
        {
            /// <summary>
            /// The type of HRTF to create.
            /// </summary>
            public IPL.HrtfType Type;
            
            /// <summary>
            /// SOFA file from which to load HRTF data. Only for @c IPL_HRTFTYPE_SOFA.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string SofaFileName;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct PanningEffect : IEquatable<PanningEffect>
        {
            private readonly IntPtr _handle;
            
            public PanningEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(PanningEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is PanningEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(PanningEffect left, PanningEffect right) => left.Equals(right);
            
            public static bool operator !=(PanningEffect left, PanningEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a panning effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PanningEffectSettings
        {
            /// <summary>
            /// The speaker layout to pan input audio to.
            /// </summary>
            public IPL.SpeakerLayout SpeakerLayout;
        }
        
        /// <summary>
        /// Parameters for applying a panning effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PanningEffectParams
        {
            /// <summary>
            /// Unit vector pointing from the listener towards the source.
            /// </summary>
            public IPL.Vector3 Direction;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct BinauralEffect : IEquatable<BinauralEffect>
        {
            private readonly IntPtr _handle;
            
            public BinauralEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(BinauralEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is BinauralEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(BinauralEffect left, BinauralEffect right) => left.Equals(right);
            
            public static bool operator !=(BinauralEffect left, BinauralEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a binaural effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct BinauralEffectSettings
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
        }
        
        /// <summary>
        /// Parameters for applying a binaural effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct BinauralEffectParams
        {
            /// <summary>
            /// Unit vector pointing from the listener towards the source.
            /// </summary>
            public IPL.Vector3 Direction;
            
            /// <summary>
            /// The interpolation technique to use.
            /// </summary>
            public IPL.HrtfInterpolation Interpolation;
            
            /// <summary>
            /// Amount to blend input audio with spatialized audio. When set to 0, output audio is not spatialized at all 
            /// and is close to input audio. If set to 1, output audio is fully spatialized.
            /// </summary>
            public float SpatialBlend;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct VirtualSurroundEffect : IEquatable<VirtualSurroundEffect>
        {
            private readonly IntPtr _handle;
            
            public VirtualSurroundEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(VirtualSurroundEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is VirtualSurroundEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(VirtualSurroundEffect left, VirtualSurroundEffect right) => left.Equals(right);
            
            public static bool operator !=(VirtualSurroundEffect left, VirtualSurroundEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a virtual surround effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct VirtualSurroundEffectSettings
        {
            /// <summary>
            /// The speaker layout that will be used by input audio buffers.
            /// </summary>
            public IPL.SpeakerLayout SpeakerLayout;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
        }
        
        /// <summary>
        /// Parameters for applying a virtual surround effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct VirtualSurroundEffectParams
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct AmbisonicsEncodeEffect : IEquatable<AmbisonicsEncodeEffect>
        {
            private readonly IntPtr _handle;
            
            public AmbisonicsEncodeEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(AmbisonicsEncodeEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is AmbisonicsEncodeEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(AmbisonicsEncodeEffect left, AmbisonicsEncodeEffect right) => left.Equals(right);
            
            public static bool operator !=(AmbisonicsEncodeEffect left, AmbisonicsEncodeEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics encode effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsEncodeEffectSettings
        {
            /// <summary>
            /// Maximum Ambisonics order to encode audio buffers to.
            /// </summary>
            public int MaxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics encode effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsEncodeEffectParams
        {
            /// <summary>
            /// Unit vector pointing from the listener towards the source.
            /// </summary>
            public IPL.Vector3 Direction;
            
            /// <summary>
            /// Ambisonic order of the output buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will generate fewer output channels, reducing CPU usage.
            /// </summary>
            public int Order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct AmbisonicsPanningEffect : IEquatable<AmbisonicsPanningEffect>
        {
            private readonly IntPtr _handle;
            
            public AmbisonicsPanningEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(AmbisonicsPanningEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is AmbisonicsPanningEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(AmbisonicsPanningEffect left, AmbisonicsPanningEffect right) => left.Equals(right);
            
            public static bool operator !=(AmbisonicsPanningEffect left, AmbisonicsPanningEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics panning effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsPanningEffectSettings
        {
            /// <summary>
            /// The speaker layout that will be used by output audio buffers.
            /// </summary>
            public IPL.SpeakerLayout SpeakerLayout;
            
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int MaxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics panning effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsPanningEffectParams
        {
            /// <summary>
            /// Ambisonic order of the input buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will process fewer input channels, reducing CPU usage.
            /// </summary>
            public int Order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct AmbisonicsBinauralEffect : IEquatable<AmbisonicsBinauralEffect>
        {
            private readonly IntPtr _handle;
            
            public AmbisonicsBinauralEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(AmbisonicsBinauralEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is AmbisonicsBinauralEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(AmbisonicsBinauralEffect left, AmbisonicsBinauralEffect right) => left.Equals(right);
            
            public static bool operator !=(AmbisonicsBinauralEffect left, AmbisonicsBinauralEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics binaural effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsBinauralEffectSettings
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
            
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int MaxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics binaural effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsBinauralEffectParams
        {
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
            
            /// <summary>
            /// Ambisonic order of the input buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will process fewer input channels, reducing CPU usage.
            /// </summary>
            public int Order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct AmbisonicsRotationEffect : IEquatable<AmbisonicsRotationEffect>
        {
            private readonly IntPtr _handle;
            
            public AmbisonicsRotationEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(AmbisonicsRotationEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is AmbisonicsRotationEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(AmbisonicsRotationEffect left, AmbisonicsRotationEffect right) => left.Equals(right);
            
            public static bool operator !=(AmbisonicsRotationEffect left, AmbisonicsRotationEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics rotation effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsRotationEffectSettings
        {
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int MaxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics rotation effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsRotationEffectParams
        {
            /// <summary>
            /// The orientation of the listener.
            /// </summary>
            public IPL.CoordinateSpace3 Orientation;
            
            /// <summary>
            /// Ambisonic order of the input and output buffers. May be less than the @c maxOrder specified when creating the 
            /// effect, in which case the effect will process fewer channels, reducing CPU usage.
            /// </summary>
            public int Order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct AmbisonicsDecodeEffect : IEquatable<AmbisonicsDecodeEffect>
        {
            private readonly IntPtr _handle;
            
            public AmbisonicsDecodeEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(AmbisonicsDecodeEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is AmbisonicsDecodeEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(AmbisonicsDecodeEffect left, AmbisonicsDecodeEffect right) => left.Equals(right);
            
            public static bool operator !=(AmbisonicsDecodeEffect left, AmbisonicsDecodeEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create an Ambisonics decode effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsDecodeEffectSettings
        {
            /// <summary>
            /// The speaker layout that will be used by output audio buffers.
            /// </summary>
            public IPL.SpeakerLayout SpeakerLayout;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
            
            /// <summary>
            /// The maximum Ambisonics order that will be used by input audio buffers.
            /// </summary>
            public int MaxOrder;
        }
        
        /// <summary>
        /// Parameters for applying an Ambisonics decode effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct AmbisonicsDecodeEffectParams
        {
            /// <summary>
            /// Ambisonic order of the input buffer. May be less than the @c maxOrder specified when creating the effect,
            /// in which case the effect will process fewer input channels, reducing CPU usage.
            /// </summary>
            public int Order;
            
            /// <summary>
            /// The HRTF to use.
            /// </summary>
            public IPL.Hrtf Hrtf;
            
            /// <summary>
            /// The orientation of the listener.
            /// </summary>
            public IPL.CoordinateSpace3 Orientation;
            
            /// <summary>
            /// Whether to use binaural rendering or panning.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool Binaural;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct DirectEffect : IEquatable<DirectEffect>
        {
            private readonly IntPtr _handle;
            
            public DirectEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(DirectEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is DirectEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(DirectEffect left, DirectEffect right) => left.Equals(right);
            
            public static bool operator !=(DirectEffect left, DirectEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a direct effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct DirectEffectSettings
        {
            /// <summary>
            /// Number of channels that will be used by input and output buffers.
            /// </summary>
            public int NumChannels;
        }
        
        /// <summary>
        /// Parameters for applying a direct effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct DirectEffectParams
        {
            /// <summary>
            /// Flags indicating which direct path effects to apply.
            /// </summary>
            public IPL.DirectEffectFlags Flags;
            
            /// <summary>
            /// Mode of applying transmission effect, if @c IPL_DIRECTEFFECTFLAGS_APPLYTRANSMISSION is enabled.
            /// </summary>
            public IPL.TransmissionType TransmissionType;
            
            /// <summary>
            /// Value of distance attenuation, between 0 and 1.
            /// </summary>
            public float DistanceAttenuation;
            
            /// <summary>
            /// 3-band EQ coefficients for air absorption, each between 0 and 1.
            /// </summary>
            public fixed float AirAbsorption[3];
            
            /// <summary>
            /// Value of directivity term, between 0 and 1.
            /// </summary>
            public float Directivity;
            
            /// <summary>
            /// Value of occlusion factor, between 0 and 1.
            /// </summary>
            public float Occlusion;
            
            /// <summary>
            /// 3-band EQ coefficients for transmission, each between 0 and 1.
            /// </summary>
            public fixed float Transmission[3];
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ReflectionEffectIR : IEquatable<ReflectionEffectIR>
        {
            private readonly IntPtr _handle;
            
            public ReflectionEffectIR(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ReflectionEffectIR other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ReflectionEffectIR other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ReflectionEffectIR left, ReflectionEffectIR right) => left.Equals(right);
            
            public static bool operator !=(ReflectionEffectIR left, ReflectionEffectIR right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ReflectionEffect : IEquatable<ReflectionEffect>
        {
            private readonly IntPtr _handle;
            
            public ReflectionEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ReflectionEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ReflectionEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ReflectionEffect left, ReflectionEffect right) => left.Equals(right);
            
            public static bool operator !=(ReflectionEffect left, ReflectionEffect right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ReflectionMixer : IEquatable<ReflectionMixer>
        {
            private readonly IntPtr _handle;
            
            public ReflectionMixer(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ReflectionMixer other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ReflectionMixer other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ReflectionMixer left, ReflectionMixer right) => left.Equals(right);
            
            public static bool operator !=(ReflectionMixer left, ReflectionMixer right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a reflection effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ReflectionEffectSettings
        {
            /// <summary>
            /// Type of reflection effect algorithm to use.
            /// </summary>
            public IPL.ReflectionEffectType Type;
            
            /// <summary>
            /// Number of samples per channel in the IR.
            /// </summary>
            public int IrSize;
            
            /// <summary>
            /// Number of channels in the IR.
            /// </summary>
            public int NumChannels;
        }
        
        /// <summary>
        /// Parameters for applying a reflection effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct ReflectionEffectParams
        {
            /// <summary>
            /// Type of reflection effect algorithm to use.
            /// </summary>
            public IPL.ReflectionEffectType Type;
            
            /// <summary>
            /// The impulse response. For @c IPL_REFLECTIONEFFECTTYPE_CONVOLUTION or @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public IPL.ReflectionEffectIR Ir;
            
            /// <summary>
            /// 3-band reverb decay times (RT60). For @c IPL_REFLECTIONEFFECTTYPE_PARAMETRIC or 
            /// @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public fixed float ReverbTimes[3];
            
            /// <summary>
            /// 3-band EQ coefficients applied to the parametric part to ensure smooth transition. 
            /// For @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public fixed float Eq[3];
            
            /// <summary>
            /// Samples after which parametric part starts. For @c IPL_REFLECTIONEFFECTTYPE_HYBRID.
            /// </summary>
            public int Delay;
            
            /// <summary>
            /// Number of IR channels to process. May be less than the number of channels specified when creating the effect,
            /// in which case CPU usage will be reduced.
            /// </summary>
            public int NumChannels;
            
            /// <summary>
            /// Number of IR samples per channel to process. May be less than the number of samples specified when creating
            /// the effect, in which case CPU usage will be reduced.
            /// </summary>
            public int IrSize;
            
            /// <summary>
            /// The TrueAudio Next device to use for convolution processing. For @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public IPL.TrueAudioNextDevice TanDevice;
            
            /// <summary>
            /// The TrueAudio Next slot index to use for convolution processing. The slot identifies the IR to use. For
            /// @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public int TanSlot;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct PathEffect : IEquatable<PathEffect>
        {
            private readonly IntPtr _handle;
            
            public PathEffect(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(PathEffect other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is PathEffect other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(PathEffect left, PathEffect right) => left.Equals(right);
            
            public static bool operator !=(PathEffect left, PathEffect right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to create a path effect.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PathEffectSettings
        {
            /// <summary>
            /// The maximum Ambisonics order that will be used by output audio buffers.
            /// </summary>
            public int MaxOrder;
        }
        
        /// <summary>
        /// Parameters for applying a path effect to an audio buffer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct PathEffectParams
        {
            /// <summary>
            /// 3-band EQ coefficients for modeling frequency-dependent attenuation caused by paths bending around
            /// obstacles.
            /// </summary>
            public fixed float EqCoeffs[3];
            
            /// <summary>
            /// Ambisonic coefficients for modeling the directional distribution of sound reaching the listener.
            /// The coefficients are specified in world-space, and must be rotated to match the listener's orientation
            /// separately.
            /// </summary>
            public IntPtr ShCoeffs;
            
            /// <summary>
            /// Ambisonic order of the output buffer. May be less than the maximum order specified when creating the effect,
            /// in which case higher-order @c shCoeffs will be ignored, and CPU usage will be reduced.
            /// </summary>
            public int Order;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ProbeArray : IEquatable<ProbeArray>
        {
            private readonly IntPtr _handle;
            
            public ProbeArray(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ProbeArray other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ProbeArray other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ProbeArray left, ProbeArray right) => left.Equals(right);
            
            public static bool operator !=(ProbeArray left, ProbeArray right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ProbeBatch : IEquatable<ProbeBatch>
        {
            private readonly IntPtr _handle;
            
            public ProbeBatch(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ProbeBatch other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ProbeBatch other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ProbeBatch left, ProbeBatch right) => left.Equals(right);
            
            public static bool operator !=(ProbeBatch left, ProbeBatch right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Settings used to generate probes.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ProbeGenerationParams
        {
            /// <summary>
            /// The algorithm to use for generating probes.
            /// </summary>
            public IPL.ProbeGenerationType Type;
            
            /// <summary>
            /// Spacing (in meters) between two neighboring probes. Only for @c IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR.
            /// </summary>
            public float Spacing;
            
            /// <summary>
            /// Height (in meters) above the floor at which probes will be generated. Only for
            /// @c IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR.
            /// </summary>
            public float Height;
            
            /// <summary>
            /// A transformation matrix that transforms an axis-aligned unit cube, with minimum and maximum vertices
            /// at (0, 0, 0) and (1, 1, 1), into a parallelopiped volume. Probes will be generated within this
            /// volume.
            /// </summary>
            public IPL.Matrix4x4 Transform;
        }
        
        /// <summary>
        /// Identifies a "layer" of data stored in a probe batch. Each probe batch may store multiple layers of data,
        /// such as reverb, static source reflections, or pathing. Each layer can be accessed using an identifier.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct BakedDataIdentifier
        {
            /// <summary>
            /// The type of data stored.
            /// </summary>
            public IPL.BakedDataType Type;
            
            /// <summary>
            /// The way in which source and listener positions depend on probe position.
            /// </summary>
            public IPL.BakedDataVariation Variation;
            
            /// <summary>
            /// The static source (for @c IPL_BAKEDDATAVARIATION_STATICSOURCE) or static listener (for
            /// @c IPL_BAKEDDATAVARIATION_STATICLISTENER) used to generate baked data. Baked data is only stored for
            /// probes that lie within the radius of this sphere.
            /// </summary>
            public IPL.Sphere EndpointInfluence;
        }
        
        /// <summary>
        /// Parameters used to control how reflections data is baked.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ReflectionsBakeParams
        {
            /// <summary>
            /// The scene in which the probes exist.
            /// </summary>
            public IPL.Scene Scene;
            
            /// <summary>
            /// A probe batch containing the probes at which reflections data should be baked.
            /// </summary>
            public IPL.ProbeBatch ProbeBatch;
            
            /// <summary>
            /// The type of scene being used.
            /// </summary>
            public IPL.SceneType SceneType;
            
            /// <summary>
            /// An identifier for the data layer that should be baked. The identifier determines what data is simulated and
            /// stored at each probe. If the probe batch already contains data with this identifier, it will be overwritten.
            /// </summary>
            public IPL.BakedDataIdentifier Identifier;
            
            /// <summary>
            /// The types of data to save for each probe.
            /// </summary>
            public IPL.ReflectionsBakeFlags BakeFlags;
            
            /// <summary>
            /// The number of rays to trace from each listener position when baking. Increasing this number results in
            /// improved accuracy, at the cost of increased bake times.
            /// </summary>
            public int NumRays;
            
            /// <summary>
            /// The number of directions to consider when generating diffusely-reflected rays when baking. Increasing
            /// this number results in slightly improved accuracy of diffuse reflections.
            /// </summary>
            public int NumDiffuseSamples;
            
            /// <summary>
            /// The number of times each ray is reflected off of solid geometry. Increasing this number results in
            /// longer reverb tails and improved accuracy, at the cost of increased bake times.
            /// </summary>
            public int NumBounces;
            
            /// <summary>
            /// The length (in seconds) of the impulse responses to simulate. Increasing this number allows the baked
            /// data to represent longer reverb tails (and hence larger spaces), at the cost of increased memory
            /// usage while baking.
            /// </summary>
            public float SimulatedDuration;
            
            /// <summary>
            /// The length (in seconds) of the impulse responses to save at each probe. Increasing this number allows
            /// the baked data to represent longer reverb tails (and hence larger spaces), at the cost of increased
            /// disk space usage and memory usage at run-time.
            /// </summary>
            /// <remarks>
            /// It may be useful to set @c savedDuration to be less than @c simulatedDuration, especially if you plan
            /// to use hybrid reverb for rendering baked reflections. This way, the parametric reverb data is
            /// estimated using a longer IR, resulting in more accurate estimation, but only the early part of the IR
            /// can be saved for subsequent rendering.
            /// </remarks>
            public float SavedDuration;
            
            /// <summary>
            /// Ambisonic order of the baked IRs.
            /// </summary>
            public int Order;
            
            /// <summary>
            /// Number of threads to use for baking.
            /// </summary>
            public int NumThreads;
            
            /// <summary>
            /// If using custom ray tracer callbacks, this the number of rays that will be passed to the callbacks
            /// every time rays need to be traced.
            /// </summary>
            public int RayBatchSize;
            
            /// <summary>
            /// When calculating how much sound energy reaches a surface directly from a source, any source that is
            /// closer than @c irradianceMinDistance to the surface is assumed to be at a distance of
            /// @c irradianceMinDistance, for the purposes of energy calculations.
            /// </summary>
            public float IrradianceMinDistance;
            
            /// <summary>
            /// If using Radeon Rays, this is the number of probes for which data is baked simultaneously.
            /// </summary>
            public int BakeBatchSize;
            
            /// <summary>
            /// The OpenCL device, if using Radeon Rays.
            /// </summary>
            public IPL.OpenCLDevice OpenCLDevice;
            
            /// <summary>
            /// The Radeon Rays device, if using Radeon Rays.
            /// </summary>
            public IPL.RadeonRaysDevice RadeonRaysDevice;
        }
        
        /// <summary>
        /// Parameters used to control how pathing data is baked.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct PathBakeParams
        {
            /// <summary>
            /// The scene in which the probes exist.
            /// </summary>
            public IPL.Scene Scene;
            
            /// <summary>
            /// A probe batch containing the probes for which pathing data should be baked.
            /// </summary>
            public IPL.ProbeBatch ProbeBatch;
            
            /// <summary>
            /// An identifier for the data layer that should be baked. The identifier determines what data is simulated and
            /// stored at each probe. If the probe batch already contains data with this identifier, it will be overwritten.
            /// </summary>
            public IPL.BakedDataIdentifier Identifier;
            
            /// <summary>
            /// Number of point samples to use around each probe when testing whether one probe can see another. To
            /// determine if two probes are mutually visible, numSamples * numSamples rays are traced, from each
            /// point sample of the first probe, to every other point sample of the second probe.
            /// </summary>
            public int NumSamples;
            
            /// <summary>
            /// When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of
            /// this radius (in meters), and point samples are generated within this sphere.
            /// </summary>
            public float Radius;
            
            /// <summary>
            /// When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that
            /// are unoccluded must be greater than this threshold for the pair of probes to be considered
            /// mutually visible.
            /// </summary>
            public float Threshold;
            
            /// <summary>
            /// If the distance between two probes is greater than this value, the probes are not considered mutually
            /// visible. Increasing this value can result in simpler paths, at the cost of increased bake times.
            /// </summary>
            public float VisRange;
            
            /// <summary>
            /// If the distance between two probes is greater than this value, the probes are considered to
            /// not have any path between them. Increasing this value allows sound to propagate over greater
            /// distances, at the cost of increased bake times and memory usage.
            /// </summary>
            public float PathRange;
            
            /// <summary>
            /// Number of threads to use for baking.
            /// </summary>
            public int NumThreads;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Source : IEquatable<Source>
        {
            private readonly IntPtr _handle;
            
            public Source(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(Source other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is Source other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(Source left, Source right) => left.Equals(right);
            
            public static bool operator !=(Source left, Source right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Simulator : IEquatable<Simulator>
        {
            private readonly IntPtr _handle;
            
            public Simulator(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(Simulator other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is Simulator other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(Simulator left, Simulator right) => left.Equals(right);
            
            public static bool operator !=(Simulator left, Simulator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A distance attenuation model that can be used for modeling attenuation of sound over distance. Can be used
        /// with both direct and indirect sound propagation.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct DistanceAttenuationModel
        {
            /// <summary>
            /// The type of distance attenuation model to use.
            /// </summary>
            public IPL.DistanceAttenuationModelType Type;
            
            /// <summary>
            /// When @c type is @c IPL_DISTANCEATTENUATIONTYPE_INVERSEDISTANCE, no distance attenuation is applied to
            /// any sound whose distance from the listener is less than this value.
            /// </summary>
            public float MinDistance;
            
            /// <summary>
            /// When @c type is @c IPL_DISTANCEATTENUATIONTYPE_CALLBACK, this function will be called whenever Steam
            /// Audio needs to evaluate distance attenuation.
            /// </summary>
            public IPL.DistanceAttenuationCallback Callback;
            
            /// <summary>
            /// Pointer to arbitrary data that will be provided to the @c callback function whenever it is called.
            /// May be @c NULL.
            /// </summary>
            public IntPtr UserData;
            
            /// <summary>
            /// Set to @c IPL_TRUE to indicate that the distance attenuation model defined by the @c callback function
            /// has changed since the last time simulation was run. For example, the callback may be evaluating a
            /// curve defined in a GUI. If the user is editing the curve in real-time, set this to @c IPL_TRUE whenever
            /// the curve changes, so Steam Audio can update simulation results to match.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool Dirty;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate float DistanceAttenuationCallback(float distance, IntPtr userData);
        
        /// <summary>
        /// An air absorption model that can be used for modeling frequency-dependent attenuation of sound over
        /// distance.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct AirAbsorptionModel
        {
            /// <summary>
            /// The type of air absorption model to use.
            /// </summary>
            public IPL.AirAbsorptionModelType Type;
            
            /// <summary>
            /// The exponential falloff coefficients to use when @c type is @c IPL_AIRABSORPTIONTYPE_EXPONENTIAL.
            /// </summary>
            public fixed float Coefficients[3];
            
            /// <summary>
            /// When @c type is @c IPL_AIRABSORPTIONTYPE_CALLBACK, this function will be called whenever Steam
            /// Audio needs to evaluate air absorption.
            /// </summary>
            public IPL.AirAbsorptionCallback Callback;
            
            /// <summary>
            /// Pointer to arbitrary data that will be provided to the @c callback function whenever it is called.
            /// May be @c NULL.
            /// </summary>
            public IntPtr UserData;
            
            /// <summary>
            /// Set to @c IPL_TRUE to indicate that the air absorption model defined by the @c callback function
            /// has changed since the last time simulation was run. For example, the callback may be evaluating a set of 
            /// curves defined in a GUI. If the user is editing the curves in real-time, set this to @c IPL_TRUE whenever
            /// the curves change, so Steam Audio can update simulation results to match.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool Dirty;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate float AirAbsorptionCallback(float distance, int band, IntPtr userData);
        
        /// <summary>
        /// A directivity pattern that can be used to model changes in sound intensity as a function of the source's
        /// orientation. Can be used with both direct and indirect sound propagation.
        /// </summary>
        /// <remarks>
        /// The default directivity model is a weighted dipole. This is a linear blend between an omnidirectional
        /// source (which emits sound with equal intensity in all directions), and a dipole oriented along the z-axis
        /// in the source's coordinate system (which focuses sound along the +z and -z axes). A callback function
        /// can be specified to implement any other arbitrary directivity pattern.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Directivity
        {
            /// <summary>
            /// How much of the dipole to blend into the directivity pattern. @c 0 = pure omnidirectional, @c 1 = pure
            /// dipole. @c 0.5f results in a cardioid directivity pattern.
            /// </summary>
            public float DipoleWeight;
            
            /// <summary>
            /// How "sharp" the dipole is. Higher values result in sound being focused within a narrower range of
            /// directions.
            /// </summary>
            public float DipolePower;
            
            /// <summary>
            /// If non @c NULL, this function will be called whenever Steam Audio needs to evaluate a directivity
            /// pattern.
            /// </summary>
            public IPL.DirectivityCallback Callback;
            
            /// <summary>
            /// Pointer to arbitrary data that will be provided to the @c callback function whenever it is called.
            /// May be @c NULL.
            /// </summary>
            public IntPtr UserData;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate float DirectivityCallback(IPL.Vector3 direction, IntPtr userData);
        
        /// <summary>
        /// Settings used to create a simulator.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SimulationSettings
        {
            /// <summary>
            /// The types of simulation that this simulator will be used for.
            /// </summary>
            public IPL.SimulationFlags Flags;
            
            /// <summary>
            /// The type of scene that will be used for simulations via @c iplSimulatorSetScene. The scene type
            /// cannot change during the lifetime of a simulator object.
            /// </summary>
            public IPL.SceneType SceneType;
            
            /// <summary>
            /// The type of reflections effect that will be used to render the results of reflections simulation.
            /// The reflections effect type cannot change during the lifetime of a simulator object.
            /// </summary>
            public IPL.ReflectionEffectType ReflectionType;
            
            /// <summary>
            /// The maximum number of point samples to consider when calculating occlusion using the
            /// volumetric occlusion algorithm. Different sources can use different numbers of samples, and the
            /// number of samples can change between simulation runs, but this is the maximum value. Increasing
            /// this value results in smoother occlusion transitions, at the cost of increased CPU usage.
            /// </summary>
            public int MaxNumOcclusionSamples;
            
            /// <summary>
            /// The maximum number of rays to trace from the listener when simulating reflections. You can use
            /// different numbers of rays between simulation runs, but this is the maximum value. Increasing
            /// this value results in more accurate reflections, at the cost of increased CPU usage.
            /// </summary>
            public int MaxNumRays;
            
            /// <summary>
            /// The number of directions to sample when generating diffusely reflected rays. Increasing this
            /// value may increase the accuracy of diffuse reflections.
            /// </summary>
            public int NumDiffuseSamples;
            
            /// <summary>
            /// The maximum length (in seconds) of impulse responses generated by reflection simulations. You
            /// can change this value betweeen simulation runs, but this is the maximum value. Increasing this
            /// value results in longer, more accurate reverb tails, at the cost of increased CPU and memory usage.
            /// </summary>
            public float MaxDuration;
            
            /// <summary>
            /// The maximum Ambisonic order of impulse responses generated by reflection simulations. You can
            /// change this value between simulation runs, but this is the maximum value. Increasing this
            /// value results in more accurate directional variations in the impulse responses, at the cost of
            /// increased CPU and memory usage.
            /// </summary>
            public int MaxOrder;
            
            /// <summary>
            /// The maximum number of sources for which reflection simulations will be run at any given time.
            /// </summary>
            public int MaxNumSources;
            
            /// <summary>
            /// The number of threads used for real-time reflection simulations.
            /// </summary>
            public int NumThreads;
            
            /// <summary>
            /// If using custom ray tracer callbacks, this the number of rays that will be passed to the callbacks
            /// every time rays need to be traced.
            /// </summary>
            public int RayBatchSize;
            
            /// <summary>
            /// The number of point samples to consider when calculating probe-to-probe visibility for pathing
            /// simulations. Baked paths may end up being occluded by dynamic objects, in which case you can configure
            /// the simulator to look for alternate paths in real time. This process will involve checking visibility
            /// between probes.
            /// </summary>
            public int NumVisSamples;
            
            /// <summary>
            /// The sampling rate (in Hz) used for audio processing.
            /// </summary>
            public int SamplingRate;
            
            /// <summary>
            /// The size (in samples) of the audio buffers used for audio processing.
            /// </summary>
            public int FrameSize;
            
            /// <summary>
            /// The OpenCL device being used. Only necessary if @sceneType is @c IPL_SCENETYPE_RADEONRAYS, or @c reflectionType is @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public IPL.OpenCLDevice OpenCLDevice;
            
            /// <summary>
            /// The Radeon Rays device being used. Only necessary if @sceneType is @c IPL_SCENETYPE_RADEONRAYS.
            /// </summary>
            public IPL.RadeonRaysDevice RadeonRaysDevice;
            
            /// <summary>
            /// The TrueAudio Next device being used. Only necessary if @c reflectionType is @c IPL_REFLECTIONEFFECTTYPE_TAN.
            /// </summary>
            public IPL.TrueAudioNextDevice TanDevice;
        }
        
        /// <summary>
        /// Settings used to create a source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SourceSettings
        {
            /// <summary>
            /// The types of simulation that may be run for this source.
            /// </summary>
            public IPL.SimulationFlags Flags;
        }
        
        /// <summary>
        /// Simulation parameters for a source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SimulationInputs
        {
            /// <summary>
            /// The types of simulation to run for this source.
            /// </summary>
            public IPL.SimulationFlags Flags;
            
            /// <summary>
            /// The types of direct simulation to run for this source.
            /// </summary>
            public IPL.DirectSimulationFlags DirectFlags;
            
            /// <summary>
            /// The position and orientation of this source.
            /// </summary>
            public IPL.CoordinateSpace3 Source;
            
            /// <summary>
            /// The distance attenuation model to use for this source.
            /// </summary>
            public IPL.DistanceAttenuationModel DistanceAttenuationModel;
            
            /// <summary>
            /// The air absorption model to use for this source.
            /// </summary>
            public IPL.AirAbsorptionModel AirAbsorptionModel;
            
            /// <summary>
            /// The directivity pattern to use for this source.
            /// </summary>
            public IPL.Directivity Directivity;
            
            /// <summary>
            /// The occlusion algorithm to use for this source.
            /// </summary>
            public IPL.OcclusionType OcclusionType;
            
            /// <summary>
            /// If using volumetric occlusion, the source is modeled as a sphere with this radius.
            /// </summary>
            public float OcclusionRadius;
            
            /// <summary>
            /// If using volumetric occlusion, this is the number of point samples to consider when
            /// tracing rays. This value can change between simulation runs.
            /// </summary>
            public int NumOcclusionSamples;
            
            /// <summary>
            /// If using parametric or hybrid reverb for rendering reflections, the reverb decay times
            /// for each frequency band are scaled by these values. Set to @c {1.0f, 1.0f, 1.0f} to use
            /// the simulated values without modification.
            /// </summary>
            public fixed float ReverbScale[3];
            
            /// <summary>
            /// If using hybrid reverb for rendering reflections, this is the length (in seconds) of
            /// impulse response to use for convolution reverb. The rest of the impulse response will
            /// be used for parametric reverb estimation only. Increasing this value results in more
            /// accurate reflections, at the cost of increased CPU usage.
            /// </summary>
            public float HybridReverbTransitionTime;
            
            /// <summary>
            /// If using hybrid reverb for rendering reflections, this is the amount of overlap between
            /// the convolution and parametric parts. To ensure smooth transitions from the early
            /// convolution part to the late parametric part, the two are cross-faded towards the end of
            /// the convolution part. For example, if @c hybridReverbTransitionTime is @c 1.0f, and 
            /// @c hybridReverbOverlapPercent is @c 0.25f, then the first 0.75 seconds are pure convolution,
            /// the next 0.25 seconds are a blend between convolution and parametric, and the portion of
            /// the tail beyond 1.0 second is pure parametric.
            /// </summary>
            public float HybridReverbOverlapPercent;
            
            /// <summary>
            /// If @c IPL_TRUE, this source will used baked data for reflections simulation.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool Baked;
            
            /// <summary>
            /// The identifier used to specify which layer of baked data to use for simulating reflections
            /// for this source.
            /// </summary>
            public IPL.BakedDataIdentifier BakedDataIdentifier;
            
            /// <summary>
            /// The probe batch within which to find paths from this source to the listener.
            /// </summary>
            public IPL.ProbeBatch PathingProbes;
            
            /// <summary>
            /// When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of
            /// this radius (in meters), and point samples are generated within this sphere.
            /// </summary>
            public float VisRadius;
            
            /// <summary>
            /// When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that
            /// are unoccluded must be greater than this threshold for the pair of probes to be considered
            /// mutually visible.
            /// </summary>
            public float VisThreshold;
            
            /// <summary>
            /// If the distance between two probes is greater than this value, the probes are not considered mutually
            /// visible. Increasing this value can result in simpler paths, at the cost of increased CPU usage.
            /// </summary>
            public float VisRange;
            
            /// <summary>
            /// If simulating pathing, this is the Ambisonic order used for representing path directionality. Higher
            /// values result in more precise spatialization of paths, at the cost of increased CPU usage.
            /// </summary>
            public int PathingOrder;
            
            /// <summary>
            /// If @c IPL_TRUE, baked paths are tested for visibility. This is useful if your scene has dynamic
            /// objects that might occlude baked paths.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool EnableValidation;
            
            /// <summary>
            /// If @c IPL_TRUE, and @c enableValidation is @c IPL_TRUE, then if a baked path is occluded by dynamic
            /// geometry, path finding is re-run in real-time to find alternate paths that take into account the
            /// dynamic geometry.
            /// </summary>
            [MarshalAs(UnmanagedType.U4)]
            public bool FindAlternatePaths;
        }
        
        /// <summary>
        /// Simulation parameters that are not specific to any source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SimulationSharedInputs
        {
            /// <summary>
            /// The position and orientation of the listener.
            /// </summary>
            public IPL.CoordinateSpace3 Listener;
            
            /// <summary>
            /// The number of rays to trace from the listener. Increasing this value results in more accurate 
            /// reflections, at the cost of increased CPU usage.
            /// </summary>
            public int NumRays;
            
            /// <summary>
            /// The number of times each ray traced from the listener is reflected when it encounters a solid
            /// object. Increasing this value results in longer, more accurate reverb tails, at the cost of
            /// increased CPU usage during simulation.
            /// </summary>
            public int NumBounces;
            
            /// <summary>
            /// The duration (in seconds) of the impulse responses generated when simulating reflections.
            /// Increasing this value results in longer, more accurate reverb tails, at the cost of increased
            /// CPU usage during audio processing.
            /// </summary>
            public float Duration;
            
            /// <summary>
            /// The Ambisonic order of the impulse responses generated when simulating reflections. Increasing
            /// this value results in more accurate directional variation of reflected sound, at the cost
            /// of increased CPU usage during audio processing.
            /// </summary>
            public int Order;
            
            /// <summary>
            /// When calculating how much sound energy reaches a surface directly from a source, any source that is
            /// closer than @c irradianceMinDistance to the surface is assumed to be at a distance of
            /// @c irradianceMinDistance, for the purposes of energy calculations.
            /// </summary>
            public float IrradianceMinDistance;
        }
        
        /// <summary>
        /// Simulation results for a source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SimulationOutputs
        {
            /// <summary>
            /// Direct path simulation results.
            /// </summary>
            public IPL.DirectEffectParams Direct;
            
            /// <summary>
            /// Reflection simulation results.
            /// </summary>
            public IPL.ReflectionEffectParams Reflections;
            
            /// <summary>
            /// Pathing simulation results.
            /// </summary>
            public IPL.PathEffectParams Pathing;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void ProgressCallback(float progress, IntPtr userData);
        
        /// <summary>
        /// Creates a context object. A context must be created before creating any other API objects.
        /// </summary>
        /// <param name="settings">Pointer to the `IPLContextSettings` struct that specifies context creation parameters.</param>
        /// <param name="context">[out] Handle to the created context object.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplContextCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ContextCreate(in IPL.ContextSettings settings, out IPL.Context context);
        
        /// <summary>
        /// Retains an additional reference to a context. The context will not be destroyed until all references are
        /// released.
        /// </summary>
        /// <param name="context">The context to retain a reference to.</param>
        /// <returns>The additional reference to the context.</returns>
        [DllImport(Library, EntryPoint = "iplContextRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Context ContextRetain(IPL.Context context);
        
        /// <summary>
        /// Releases a reference to a context. The context will not be destroyed until all references are released.
        /// </summary>
        /// <param name="context">[in, out] The context to release.</param>
        [DllImport(Library, EntryPoint = "iplContextRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ContextRelease(ref IPL.Context context);
        
        /// <summary>
        /// Calculates the relative direction from the listener to a sound source. The returned direction
        /// vector is expressed in the listener's coordinate system.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="sourcePosition">World-space coordinates of the source.</param>
        /// <param name="listenerPosition">World-space coordinates of the listener.</param>
        /// <param name="listenerAhead">World-space unit-length vector pointing ahead relative to the listener.</param>
        /// <param name="listenerUp">World-space unit-length vector pointing up relative to the listener.</param>
        /// <returns>A unit-length vector in the listener's coordinate space, pointing from the listener to the source.</returns>
        [DllImport(Library, EntryPoint = "iplCalculateRelativeDirection", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Vector3 CalculateRelativeDirection(IPL.Context context, IPL.Vector3 sourcePosition, IPL.Vector3 listenerPosition, IPL.Vector3 listenerAhead, IPL.Vector3 listenerUp);
        
        /// <summary>
        /// Creates a serialized object.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the serialized object.</param>
        /// <param name="serializedObject">[out] The created serialized object.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSerializedObjectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SerializedObjectCreate(IPL.Context context, in IPL.SerializedObjectSettings settings, out IPL.SerializedObject serializedObject);
        
        /// <summary>
        /// Retains an additional reference to a serialized object.
        /// </summary>
        /// <param name="serializedObject">The serialized object to retain a reference to.</param>
        /// <returns>The additional reference to the serialized object.</returns>
        [DllImport(Library, EntryPoint = "iplSerializedObjectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.SerializedObject SerializedObjectRetain(IPL.SerializedObject serializedObject);
        
        /// <summary>
        /// Releases a reference to a serialized object.
        /// </summary>
        /// <param name="serializedObject">The serialized object to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSerializedObjectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SerializedObjectRelease(ref IPL.SerializedObject serializedObject);
        
        /// <param name="serializedObject">The serialized object.</param>
        /// <returns>The size in bytes of the serialized data contained in a serialized object.</returns>
        [DllImport(Library, EntryPoint = "iplSerializedObjectGetSize", CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong SerializedObjectGetSize(IPL.SerializedObject serializedObject);
        
        /// <param name="serializedObject">The serialized object.</param>
        /// <returns>A pointer to a byte array of serialized data contained in a serialized object.</returns>
        [DllImport(Library, EntryPoint = "iplSerializedObjectGetData", CallingConvention = CallingConvention.Cdecl)]
        public static extern ref byte SerializedObjectGetData(IPL.SerializedObject serializedObject);
        
        /// <summary>
        /// Creates an Embree device.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the Embree device.</param>
        /// <param name="device">[out] The created Embree device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplEmbreeDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error EmbreeDeviceCreate(IPL.Context context, in IPL.EmbreeDeviceSettings settings, out IPL.EmbreeDevice device);
        
        /// <summary>
        /// Retains an additional reference to an Embree device.
        /// </summary>
        /// <param name="device">The Embree device to retain a reference to.</param>
        /// <returns>The additional reference to the Embree device.</returns>
        [DllImport(Library, EntryPoint = "iplEmbreeDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.EmbreeDevice EmbreeDeviceRetain(IPL.EmbreeDevice device);
        
        /// <summary>
        /// Releases a reference to an Embree device.
        /// </summary>
        /// <param name="device">The Embree device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplEmbreeDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void EmbreeDeviceRelease(ref IPL.EmbreeDevice device);
        
        /// <summary>
        /// Creates an OpenCL device list. This involves listing all available OpenCL devices on the user's system.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The requirements that all listed OpenCL devices must satisfy.</param>
        /// <param name="deviceList">[out] The created OpenCL device list.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error OpenCLDeviceListCreate(IPL.Context context, in IPL.OpenCLDeviceSettings settings, out IPL.OpenCLDeviceList deviceList);
        
        /// <summary>
        /// Retains an additional reference to an OpenCL device list.
        /// </summary>
        /// <param name="deviceList">The OpenCL device list to retain a reference to.</param>
        /// <returns>The additional reference to the OpenCL device list.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.OpenCLDeviceList OpenCLDeviceListRetain(IPL.OpenCLDeviceList deviceList);
        
        /// <summary>
        /// Releases a reference to an OpenCL device list.
        /// </summary>
        /// <param name="deviceList">The OpenCL device list to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void OpenCLDeviceListRelease(ref IPL.OpenCLDeviceList deviceList);
        
        /// <param name="deviceList">The OpenCL device list.</param>
        /// <returns>The number of devices in an OpenCL device list.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListGetNumDevices", CallingConvention = CallingConvention.Cdecl)]
        public static extern int OpenCLDeviceListGetNumDevices(IPL.OpenCLDeviceList deviceList);
        
        /// <summary>
        /// Retrieves information about a specific device in an OpenCL device list.
        /// </summary>
        /// <param name="deviceList">The OpenCL device list.</param>
        /// <param name="index">The index of the device within the list.</param>
        /// <param name="deviceDesc">[out] A descriptor for the properties of the specified OpenCL device.</param>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceListGetDeviceDesc", CallingConvention = CallingConvention.Cdecl)]
        public static extern void OpenCLDeviceListGetDeviceDesc(IPL.OpenCLDeviceList deviceList, int index, out IPL.OpenCLDeviceDesc deviceDesc);
        
        /// <summary>
        /// Creates an OpenCL device. The device is specified as an index into an OpenCL device list.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="deviceList">The OpenCL device list.</param>
        /// <param name="index">The index of the device within the list.</param>
        /// <param name="device">[out] The created OpenCL device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error OpenCLDeviceCreate(IPL.Context context, IPL.OpenCLDeviceList deviceList, int index, out IPL.OpenCLDevice device);
        
        /// <summary>
        /// Creates an OpenCL device from an existing OpenCL device created by your application. Steam Audio will
        /// use up to two command queues that you provide for enqueuing OpenCL computations.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="convolutionQueue">The @c cl_command_queue to use for enqueueing convolution work.</param>
        /// <param name="irUpdateQueue">The @c cl_command_queue to use for enqueueing IR update work.</param>
        /// <param name="device">[out] The created OpenCL device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceCreateFromExisting", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error OpenCLDeviceCreateFromExisting(IPL.Context context, IntPtr convolutionQueue, IntPtr irUpdateQueue, out IPL.OpenCLDevice device);
        
        /// <summary>
        /// Retains an additional reference to an OpenCL device.
        /// </summary>
        /// <param name="device">The OpenCL device to retain a reference to.</param>
        /// <returns>The additional reference to the OpenCL device.</returns>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.OpenCLDevice OpenCLDeviceRetain(IPL.OpenCLDevice device);
        
        /// <summary>
        /// Releases a reference to an OpenCL device.
        /// </summary>
        /// <param name="device">The OpenCL device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplOpenCLDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void OpenCLDeviceRelease(ref IPL.OpenCLDevice device);
        
        /// <summary>
        /// Creates a Radeon Rays device.
        /// </summary>
        /// <param name="openCLDevice">The OpenCL device to use for running Radeon Rays.</param>
        /// <param name="settings">The settings to use when creating the Radeon Rays device.</param>
        /// <param name="rrDevice">[out] The created Radeon Rays device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplRadeonRaysDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error RadeonRaysDeviceCreate(IPL.OpenCLDevice openCLDevice, in IPL.RadeonRaysDeviceSettings settings, out IPL.RadeonRaysDevice rrDevice);
        
        /// <summary>
        /// Retains an additional reference to a Radeon Rays device.
        /// </summary>
        /// <param name="device">The Radeon Rays device to retain a reference to.</param>
        /// <returns>The additional reference to the Radeon Rays device.</returns>
        [DllImport(Library, EntryPoint = "iplRadeonRaysDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.RadeonRaysDevice RadeonRaysDeviceRetain(IPL.RadeonRaysDevice device);
        
        /// <summary>
        /// Releases a reference to a Radeon Rays device.
        /// </summary>
        /// <param name="device">The Radeon Rays device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplRadeonRaysDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void RadeonRaysDeviceRelease(ref IPL.RadeonRaysDevice device);
        
        /// <summary>
        /// Creates a TrueAudio Next device.
        /// </summary>
        /// <param name="openCLDevice">The OpenCL device to use for running TrueAudio Next.</param>
        /// <param name="settings">The settings to use when creating the TrueAudio Next device.</param>
        /// <param name="tanDevice">[out] The created TrueAudio Next device.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplTrueAudioNextDeviceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error TrueAudioNextDeviceCreate(IPL.OpenCLDevice openCLDevice, in IPL.TrueAudioNextDeviceSettings settings, out IPL.TrueAudioNextDevice tanDevice);
        
        /// <summary>
        /// Retains an additional reference to a TrueAudio Next device.
        /// </summary>
        /// <param name="device">The TrueAudio Next device to retain a reference to.</param>
        /// <returns>The additional reference to the TrueAudio Next device.</returns>
        [DllImport(Library, EntryPoint = "iplTrueAudioNextDeviceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.TrueAudioNextDevice TrueAudioNextDeviceRetain(IPL.TrueAudioNextDevice device);
        
        /// <summary>
        /// Releases a reference to a TrueAudio Next device.
        /// </summary>
        /// <param name="device">The TrueAudio Next device to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplTrueAudioNextDeviceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void TrueAudioNextDeviceRelease(ref IPL.TrueAudioNextDevice device);
        
        /// <summary>
        /// Creates a scene.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the scene.</param>
        /// <param name="scene">[out] The created scene.</param>
        /// <returns>Status code indicating success or failure.</returns>
        /// <remarks>
        /// A scene does not store any geometry information on its own; for that you need to create one or more
        /// static meshes or instanced meshes and add them to the scene.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SceneCreate(IPL.Context context, in IPL.SceneSettings settings, out IPL.Scene scene);
        
        /// <summary>
        /// Retains an additional reference to a scene.
        /// </summary>
        /// <param name="scene">The scene to retain a reference to.</param>
        /// <returns>The additional reference to the scene.</returns>
        [DllImport(Library, EntryPoint = "iplSceneRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Scene SceneRetain(IPL.Scene scene);
        
        /// <summary>
        /// Releases a reference to a scene.
        /// </summary>
        /// <param name="scene">The scene to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSceneRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneRelease(ref IPL.Scene scene);
        
        /// <summary>
        /// Loads a scene from a serialized object. Typically, the serialized object will be created from a byte array
        /// loaded from disk or over the network.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the scene.</param>
        /// <param name="serializedObject">The serialized object from which to load the scene.</param>
        /// <param name="progressCallback">Callback that reports the percentage of this function's work that has been completed. May be @c NULL.</param>
        /// <param name="progressCallbackUserData">Pointer to arbitrary data that will be passed to the progress callback. May be @c NULL.</param>
        /// <param name="scene">[out] The created scene.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSceneLoad", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SceneLoad(IPL.Context context, in IPL.SceneSettings settings, IPL.SerializedObject serializedObject, IPL.ProgressCallback progressCallback, IntPtr progressCallbackUserData, out IPL.Scene scene);
        
        /// <summary>
        /// Saves a scene to a serialized object. Typically, the serialized object will then be saved to disk.
        /// </summary>
        /// <param name="scene">The scene to save.</param>
        /// <param name="serializedObject">The serialized object into which to save the scene.</param>
        /// <remarks>
        /// *This function can only be called on a scene created with @c IPL_SCENETYPE_DEFAULT.**
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneSave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneSave(IPL.Scene scene, IPL.SerializedObject serializedObject);
        
        /// <summary>
        /// Saves a scene to an OBJ file.
        /// </summary>
        /// <param name="scene">The scene to save.</param>
        /// <param name="fileBaseName">Absolute or relative path to the OBJ file to generate.</param>
        /// <remarks>
        /// An OBJ file is a widely-supported 3D model file format, that can be displayed using a variety of software 
        /// on most PC platforms. The OBJ file generated by this function can be useful for detecting problems that 
        /// occur when exporting scene data from your application to Steam Audio.*This function can only be called on a scene created with @c IPL_SCENETYPE_DEFAULT or @c IPL_SCENETYPE_EMBREE.**
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneSaveOBJ", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneSaveOBJ(IPL.Scene scene, [MarshalAs(UnmanagedType.LPStr)] string fileBaseName);
        
        /// <summary>
        /// Commits any changes to the scene.
        /// </summary>
        /// <param name="scene">The scene to commit changes to.</param>
        /// <remarks>
        /// This function should be called after any calls to the following functions, for the changes to take effect:-   @c iplStaticMeshAdd -   @c iplStaticMeshRemove -   @c iplInstancedMeshAdd -   @c iplInstancedMeshRemove -   @c iplInstancedMeshUpdateTransform For best performance, call this function once after all changes have been made for a given frame.*This function cannot be called concurrently with any simulation functions.**
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSceneCommit", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SceneCommit(IPL.Scene scene);
        
        /// <summary>
        /// Creates a static mesh.
        /// </summary>
        /// <param name="scene">The scene in which the static mesh should be created.</param>
        /// <param name="settings">The settings to use when creating the static mesh.</param>
        /// <param name="staticMesh">[out] The created static mesh.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// A static mesh represents a triangle mesh that does not change after it is created. A static mesh also contains 
        /// an array of acoustic material properties, and a mapping between each of its triangles and their acoustic material 
        /// properties.Static mesh objects should be used for scene geometry that is guaranteed to never change, such as rooms, 
        /// buildings, or triangulated terrain. A scene may contain multiple static meshes, although typically one 
        /// is sufficient.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error StaticMeshCreate(IPL.Scene scene, in IPL.StaticMeshSettings settings, out IPL.StaticMesh staticMesh);
        
        /// <summary>
        /// Retains an additional reference to a static mesh.
        /// </summary>
        /// <param name="staticMesh">The static mesh to retain a reference to.</param>
        /// <returns>The additional reference to the static mesh.</returns>
        [DllImport(Library, EntryPoint = "iplStaticMeshRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.StaticMesh StaticMeshRetain(IPL.StaticMesh staticMesh);
        
        /// <summary>
        /// Releases a reference to a static mesh.
        /// </summary>
        /// <param name="staticMesh">The static mesh to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplStaticMeshRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshRelease(ref IPL.StaticMesh staticMesh);
        
        /// <summary>
        /// Loads a static mesh from a serialized object. Typically, the serialized object will be created from a byte array
        /// loaded from disk or over the network.
        /// </summary>
        /// <param name="scene">The scene in which the static mesh should be created.</param>
        /// <param name="serializedObject">The serialized object from which to load the scene.</param>
        /// <param name="progressCallback">Callback that reports the percentage of this function's work that has been completed. May be @c NULL.</param>
        /// <param name="progressCallbackUserData">Pointer to arbitrary data that will be passed to the progress callback. May be @c NULL.</param>
        /// <param name="staticMesh">[out] The created static mesh.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplStaticMeshLoad", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error StaticMeshLoad(IPL.Scene scene, IPL.SerializedObject serializedObject, IPL.ProgressCallback progressCallback, IntPtr progressCallbackUserData, out IPL.StaticMesh staticMesh);
        
        /// <summary>
        /// Saves a static mesh to a serialized object. Typically, the serialized object will then be saved to disk.
        /// </summary>
        /// <param name="staticMesh">The static mesh to save.</param>
        /// <param name="serializedObject">The serialized object into which to save the static mesh.</param>
        /// <remarks>
        /// This function can only be called on a static mesh that is part of a scene created with @c IPL_SCENETYPE_DEFAULT.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshSave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshSave(IPL.StaticMesh staticMesh, IPL.SerializedObject serializedObject);
        
        /// <summary>
        /// Adds a static mesh to a scene.
        /// </summary>
        /// <param name="staticMesh">The static mesh to add.</param>
        /// <param name="scene">The scene to which to add the static mesh. This must be the scene which was passed when
        /// calling @c iplStaticMeshCreate.</param>
        /// <remarks>
        /// This function should be called after @c iplStaticMeshCreate, or at any point after @c iplStaticMeshRemove, for the static mesh to start affecting sound propagation.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshAdd", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshAdd(IPL.StaticMesh staticMesh, IPL.Scene scene);
        
        /// <summary>
        /// Removes a static mesh from a scene.
        /// </summary>
        /// <param name="staticMesh">The static mesh to remove.</param>
        /// <param name="scene">The scene from which to remove the static mesh. This must be the scene which was passed when
        /// calling @c iplStaticMeshCreate.</param>
        /// <remarks>
        /// After this function is called, the static mesh will stop affecting sound propagation, until it is
        /// added back using @c iplStaticMeshAdd.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplStaticMeshRemove", CallingConvention = CallingConvention.Cdecl)]
        public static extern void StaticMeshRemove(IPL.StaticMesh staticMesh, IPL.Scene scene);
        
        /// <summary>
        /// Creates an instanced mesh.
        /// </summary>
        /// <param name="scene">The scene in which the instanced mesh should be created.</param>
        /// <param name="settings">The settings used to create the instanced mesh.</param>
        /// <param name="instancedMesh">[out] The created instanced mesh.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// An instanced mesh takes one scene and positions it within another scene. This is useful if you have the
        /// same object, like a pillar, that you want to instantiate multiple times within the same scene. A scene
        /// can be instantiated multiple times within another scene, without incurring any significant memory overhead.The instanced mesh can be moved, rotated, and scaled freely at any time, providing an easy way to implement
        /// dynamic objects whose motion can be described purely in terms of rigid-body transformations.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error InstancedMeshCreate(IPL.Scene scene, in IPL.InstancedMeshSettings settings, out IPL.InstancedMesh instancedMesh);
        
        /// <summary>
        /// Retains an additional reference to a instanced mesh.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to retain a reference to.</param>
        /// <returns>The additional reference to the instanced mesh.</returns>
        [DllImport(Library, EntryPoint = "iplInstancedMeshRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.InstancedMesh InstancedMeshRetain(IPL.InstancedMesh instancedMesh);
        
        /// <summary>
        /// Releases a reference to a instanced mesh.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplInstancedMeshRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshRelease(ref IPL.InstancedMesh instancedMesh);
        
        /// <summary>
        /// Adds an instanced mesh to a scene.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to add.</param>
        /// <param name="scene">The scene to which to add the instanced mesh. This must be the scene which was passed when
        /// calling @c iplInstancedMeshCreate.</param>
        /// <remarks>
        /// This function should be called after @c iplInstancedMeshCreate, or at any point after @c iplInstancedMeshRemove, for the instanced mesh to start affecting sound propagation.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshAdd", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshAdd(IPL.InstancedMesh instancedMesh, IPL.Scene scene);
        
        /// <summary>
        /// Removes an instanced mesh from a scene.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh to remove.</param>
        /// <param name="scene">The scene from which to remove the instanced mesh. This must be the scene which was passed when
        /// calling @c iplInstancedMeshCreate.</param>
        /// <remarks>
        /// After this function is called, the instanced mesh will stop affecting sound propagation, until it is
        /// added back using @c iplInstancedMeshAdd.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshRemove", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshRemove(IPL.InstancedMesh instancedMesh, IPL.Scene scene);
        
        /// <summary>
        /// Updates the local-to-world transform of an instanced mesh within its parent scene.
        /// </summary>
        /// <param name="instancedMesh">The instanced mesh whose transform is to be updated.</param>
        /// <param name="scene">The parent scene that contains the instanced mesh.</param>
        /// <param name="transform">The new 4x4 local-to-world transform matrix.</param>
        /// <remarks>
        /// This function allows the instanced mesh to be moved, rotated, and scaled dynamically.After calling this function, @c iplSceneCommit must be called for the changes to take effect.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplInstancedMeshUpdateTransform", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstancedMeshUpdateTransform(IPL.InstancedMesh instancedMesh, IPL.Scene scene, IPL.Matrix4x4 transform);
        
        /// <summary>
        /// Allocates an audio buffer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="numChannels">Number of channels.</param>
        /// <param name="numSamples">Number of samples per channel.</param>
        /// <param name="audioBuffer">The audio buffer to allocate.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// All audio buffers are uncompressed PCM with 32-bit floating-point samples.Internally, all audio buffers are stored deinterleaved for performance reasons. If your audio engine provides
        /// interleaved audio buffers, you must use @c iplAudioBufferInterleave and @c iplAudioBufferDeinterleave to explicitly
        /// convert to/from deinterleaved format. If your audio engine provides deinterleaved audio buffers, you can
        /// pass them directly using @c IPLAudioBuffer, thus avoiding the processing and memory overhead of an extra audio buffer.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferAllocate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AudioBufferAllocate(IPL.Context context, int numChannels, int numSamples, ref IPL.AudioBuffer audioBuffer);
        
        /// <summary>
        /// Frees an audio buffer.
        /// </summary>
        /// <param name="audioBuffer">The audio buffer to free.</param>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        [DllImport(Library, EntryPoint = "iplAudioBufferFree", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferFree(IPL.Context context, ref IPL.AudioBuffer audioBuffer);
        
        /// <summary>
        /// Reads samples from an audio buffer and interleaves them into a user-provided array.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="src">The audio buffer to read from.</param>
        /// <param name="dst">The interleaved array to write into.</param>
        [DllImport(Library, EntryPoint = "iplAudioBufferInterleave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferInterleave(IPL.Context context, in IPL.AudioBuffer src, in float dst);
        
        /// <summary>
        /// Writes interleaved samples from a user-provided array into an audio buffer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="src">The interleaved array to read from.</param>
        /// <param name="dst">The audio buffer to write into.</param>
        [DllImport(Library, EntryPoint = "iplAudioBufferDeinterleave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferDeinterleave(IPL.Context context, in float src, in IPL.AudioBuffer dst);
        
        /// <summary>
        /// Mixes one audio buffer into another.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="in">The source audio buffer.</param>
        /// <param name="mix">The destination audio buffer, into which the source should be mixed.</param>
        /// <remarks>
        /// Both audio buffers must have the same number of channels and samples.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferMix", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferMix(IPL.Context context, ref IPL.AudioBuffer @in, in IPL.AudioBuffer mix);
        
        /// <summary>
        /// Downmixes a multi-channel audio buffer into a mono audio buffer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="in">The source audio buffer.</param>
        /// <param name="out">The destination audio buffer.</param>
        /// <remarks>
        /// Both audio buffers must have the same number of samples.Downmixing is performed by summing up the source channels and dividing the result by the
        /// number of source channels. If this is not the desired downmixing behavior, we recommend
        /// that downmixing be performed manually.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferDownmix", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferDownmix(IPL.Context context, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Converts an Ambisonic audio buffer from one Ambisonic format to another.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="inType">Ambisonic format of @c in.</param>
        /// <param name="outType">Ambisonic format that @c out should be in.</param>
        /// <param name="in">The source audio buffer.</param>
        /// <param name="out">The destination audio buffer.</param>
        /// <remarks>
        /// Both audio buffers must have the same number of samples.This conversion can be applied in-place, i.e., @c in and @c out can be the same 
        /// audio buffer.Steam Audio's "native" Ambisonic format is N3D, so for best performance, keep all
        /// Ambisonic data in N3D format except when exchanging data with your audio engine.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAudioBufferConvertAmbisonics", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AudioBufferConvertAmbisonics(IPL.Context context, IPL.AmbisonicsType inType, IPL.AmbisonicsType outType, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an HRTF.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="hrtfSettings">The settings used to create the HRTF object.</param>
        /// <param name="hrtf">[out] The created HRTF object.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        /// <remarks>
        /// Calling this function is somewhat expensive; avoid creating HRTF objects in your audio thread at all 
        /// if possible.This function is not thread-safe. Do not simultaneously call it from multiple threads.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplHRTFCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error HrtfCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.HrtfSettings hrtfSettings, out IPL.Hrtf hrtf);
        
        /// <summary>
        /// Retains an additional reference to an HRTF object.
        /// </summary>
        /// <param name="hrtf">The HRTF object to retain a reference to.</param>
        /// <returns>The additional reference to the HRTF object.</returns>
        [DllImport(Library, EntryPoint = "iplHRTFRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Hrtf HrtfRetain(IPL.Hrtf hrtf);
        
        /// <summary>
        /// Releases a reference to an HRTF object.
        /// </summary>
        /// <param name="hrtf">The HRTF object to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplHRTFRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void HrtfRelease(ref IPL.Hrtf hrtf);
        
        /// <summary>
        /// Creates a panning effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the panning effect.</param>
        /// <param name="effect">[out] The created panning effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplPanningEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error PanningEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.PanningEffectSettings effectSettings, out IPL.PanningEffect effect);
        
        /// <summary>
        /// Retains an additional reference to a panning effect.
        /// </summary>
        /// <param name="effect">The panning effect to retain a reference to.</param>
        /// <returns>The additional reference to the panning effect.</returns>
        [DllImport(Library, EntryPoint = "iplPanningEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.PanningEffect PanningEffectRetain(IPL.PanningEffect effect);
        
        /// <summary>
        /// Releases a reference to a panning effect.
        /// </summary>
        /// <param name="effect">The panning effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplPanningEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PanningEffectRelease(ref IPL.PanningEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of a panning effect.
        /// </summary>
        /// <param name="effect">The panning effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplPanningEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PanningEffectReset(IPL.PanningEffect effect);
        
        /// <summary>
        /// Applies a panning effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The panning effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must be 1-channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the panning effect. For example, if the speaker layout is
        /// @c IPL_SPEAKERLAYOUTTYPE_SURROUND_5_1, the output buffer must contain 6 channels.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplPanningEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState PanningEffectApply(IPL.PanningEffect effect, ref IPL.PanningEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a binaural effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the binaural effect.</param>
        /// <param name="effect">[out] The created binaural effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplBinauralEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error BinauralEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.BinauralEffectSettings effectSettings, out IPL.BinauralEffect effect);
        
        /// <summary>
        /// Retains an additional reference to a binaural effect.
        /// </summary>
        /// <param name="effect">The binaural effect to retain a reference to.</param>
        /// <returns>The additional reference to the binaural effect.</returns>
        [DllImport(Library, EntryPoint = "iplBinauralEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.BinauralEffect BinauralEffectRetain(IPL.BinauralEffect effect);
        
        /// <summary>
        /// Releases a reference to a binaural effect.
        /// </summary>
        /// <param name="effect">The binaural effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplBinauralEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void BinauralEffectRelease(ref IPL.BinauralEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of a binaural effect.
        /// </summary>
        /// <param name="effect">The binaural effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplBinauralEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void BinauralEffectReset(IPL.BinauralEffect effect);
        
        /// <summary>
        /// Applies a binaural effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The binaural effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must be 1- or 2-channel.</param>
        /// <param name="out">The output audio buffer. Must be 2-channel.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplBinauralEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState BinauralEffectApply(IPL.BinauralEffect effect, ref IPL.BinauralEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a virtual surround effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the virtual surround effect.</param>
        /// <param name="effect">[out] The created virtual surround effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error VirtualSurroundEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.VirtualSurroundEffectSettings effectSettings, out IPL.VirtualSurroundEffect effect);
        
        /// <summary>
        /// Retains an additional reference to a virtual surround effect.
        /// </summary>
        /// <param name="effect">The virtual surround effect to retain a reference to.</param>
        /// <returns>The additional reference to the virtual surround effect.</returns>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.VirtualSurroundEffect VirtualSurroundEffectRetain(IPL.VirtualSurroundEffect effect);
        
        /// <summary>
        /// Releases a reference to a virtual surround effect.
        /// </summary>
        /// <param name="effect">The virtual surround effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void VirtualSurroundEffectRelease(ref IPL.VirtualSurroundEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of a virtual surround effect.
        /// </summary>
        /// <param name="effect">The virtual surround effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void VirtualSurroundEffectReset(IPL.VirtualSurroundEffect effect);
        
        /// <summary>
        /// Applies a virtual surround effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The virtual surround effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the virtual surround effect.</param>
        /// <param name="out">The output audio buffer. Must be 2-channel.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplVirtualSurroundEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState VirtualSurroundEffectApply(IPL.VirtualSurroundEffect effect, ref IPL.VirtualSurroundEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics encode effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics encode effect.</param>
        /// <param name="effect">[out] The created Ambisonics encode effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsEncodeEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.AmbisonicsEncodeEffectSettings effectSettings, out IPL.AmbisonicsEncodeEffect effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics encode effect.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics encode effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AmbisonicsEncodeEffect AmbisonicsEncodeEffectRetain(IPL.AmbisonicsEncodeEffect effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics encode effect.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsEncodeEffectRelease(ref IPL.AmbisonicsEncodeEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics encode effect.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsEncodeEffectReset(IPL.AmbisonicsEncodeEffect effect);
        
        /// <summary>
        /// Applies an Ambisonics encode effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics encode effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must be 1-channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the
        /// Ambisonics order specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsEncodeEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsEncodeEffectApply(IPL.AmbisonicsEncodeEffect effect, ref IPL.AmbisonicsEncodeEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics panning effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics panning effect.</param>
        /// <param name="effect">[out] The created Ambisonics panning effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsPanningEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.AmbisonicsPanningEffectSettings effectSettings, out IPL.AmbisonicsPanningEffect effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics panning effect.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics panning effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AmbisonicsPanningEffect AmbisonicsPanningEffectRetain(IPL.AmbisonicsPanningEffect effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics panning effect.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsPanningEffectRelease(ref IPL.AmbisonicsPanningEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics panning effect.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsPanningEffectReset(IPL.AmbisonicsPanningEffect effect);
        
        /// <summary>
        /// Applies an Ambisonics panning effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics panning effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified in the parameters.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsPanningEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsPanningEffectApply(IPL.AmbisonicsPanningEffect effect, ref IPL.AmbisonicsPanningEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics binaural effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics binaural effect.</param>
        /// <param name="effect">[out] The created Ambisonics binaural effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsBinauralEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.AmbisonicsBinauralEffectSettings effectSettings, out IPL.AmbisonicsBinauralEffect effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics binaural effect.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics binaural effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AmbisonicsBinauralEffect AmbisonicsBinauralEffectRetain(IPL.AmbisonicsBinauralEffect effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics binaural effect.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsBinauralEffectRelease(ref IPL.AmbisonicsBinauralEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics binaural effect.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsBinauralEffectReset(IPL.AmbisonicsBinauralEffect effect);
        
        /// <summary>
        /// Applies an Ambisonics binaural effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics binaural effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified in the parameters.</param>
        /// <param name="out">The output audio buffer. Must have 2 channels.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsBinauralEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsBinauralEffectApply(IPL.AmbisonicsBinauralEffect effect, ref IPL.AmbisonicsBinauralEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics rotation effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics rotation effect.</param>
        /// <param name="effect">[out] The created Ambisonics rotation effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsRotationEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.AmbisonicsRotationEffectSettings effectSettings, out IPL.AmbisonicsRotationEffect effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics rotation effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AmbisonicsRotationEffect AmbisonicsRotationEffectRetain(IPL.AmbisonicsRotationEffect effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsRotationEffectRelease(ref IPL.AmbisonicsRotationEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsRotationEffectReset(IPL.AmbisonicsRotationEffect effect);
        
        /// <summary>
        /// Applies an Ambisonics rotation effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified when creating the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsRotationEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsRotationEffectApply(IPL.AmbisonicsRotationEffect effect, ref IPL.AmbisonicsRotationEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an Ambisonics rotation effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the Ambisonics rotation effect.</param>
        /// <param name="effect">[out] The created Ambisonics rotation effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error AmbisonicsDecodeEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.AmbisonicsDecodeEffectSettings effectSettings, out IPL.AmbisonicsDecodeEffect effect);
        
        /// <summary>
        /// Retains an additional reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to retain a reference to.</param>
        /// <returns>The additional reference to the Ambisonics rotation effect.</returns>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AmbisonicsDecodeEffect AmbisonicsDecodeEffectRetain(IPL.AmbisonicsDecodeEffect effect);
        
        /// <summary>
        /// Releases a reference to an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsDecodeEffectRelease(ref IPL.AmbisonicsDecodeEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of an Ambisonics rotation effect.
        /// </summary>
        /// <param name="effect">The Ambisonics rotation effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AmbisonicsDecodeEffectReset(IPL.AmbisonicsDecodeEffect effect);
        
        /// <summary>
        /// Applies an Ambisonics decode effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The Ambisonics decode effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as needed for the Ambisonics order
        /// specified when creating the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the speaker layout
        /// specified when creating the effect (if using panning) or 2 channels (if using
        /// binaural rendering).</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplAmbisonicsDecodeEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState AmbisonicsDecodeEffectApply(IPL.AmbisonicsDecodeEffect effect, ref IPL.AmbisonicsDecodeEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a direct effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the direct effect.</param>
        /// <param name="effect">[out] The created direct effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplDirectEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error DirectEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.DirectEffectSettings effectSettings, out IPL.DirectEffect effect);
        
        /// <summary>
        /// Retains an additional reference to a direct effect.
        /// </summary>
        /// <param name="effect">The direct effect to retain a reference to.</param>
        /// <returns>The additional reference to the direct effect.</returns>
        [DllImport(Library, EntryPoint = "iplDirectEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.DirectEffect DirectEffectRetain(IPL.DirectEffect effect);
        
        /// <summary>
        /// Releases a reference to a direct effect.
        /// </summary>
        /// <param name="effect">The direct effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplDirectEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void DirectEffectRelease(ref IPL.DirectEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of a direct effect.
        /// </summary>
        /// <param name="effect">The direct effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplDirectEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void DirectEffectReset(IPL.DirectEffect effect);
        
        /// <summary>
        /// Applies a direct effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The direct effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have as many channels as specified when creating the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CAN be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplDirectEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState DirectEffectApply(IPL.DirectEffect effect, ref IPL.DirectEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a reflection effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the reflection effect.</param>
        /// <param name="effect">[out] The created reflection effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ReflectionEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.ReflectionEffectSettings effectSettings, out IPL.ReflectionEffect effect);
        
        /// <summary>
        /// Retains an additional reference to a reflection effect.
        /// </summary>
        /// <param name="effect">The reflection effect to retain a reference to.</param>
        /// <returns>The additional reference to the reflection effect.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.ReflectionEffect ReflectionEffectRetain(IPL.ReflectionEffect effect);
        
        /// <summary>
        /// Releases a reference to a reflection effect.
        /// </summary>
        /// <param name="effect">The reflection effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplReflectionEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionEffectRelease(ref IPL.ReflectionEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of a reflection effect.
        /// </summary>
        /// <param name="effect">The reflection effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplReflectionEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionEffectReset(IPL.ReflectionEffect effect);
        
        /// <summary>
        /// Applies a reflection effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The reflection effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have 1 channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as the impulse response
        /// specified when creating the effect (for convolution, hybrid, and TAN) or at
        /// least 1 channel (for parametric).</param>
        /// <param name="mixer">If this is non-null, then the output of this effect will be mixed into the given
        /// mixer object instead of being returned in the @c out parameter. The mixed output can
        /// be retrieved elsewhere in the audio pipeline using @c iplReflectionMixerApply. This
        /// can have a performance benefit if using convolution. If using TAN, specifying
        /// a mixer is required.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplReflectionEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState ReflectionEffectApply(IPL.ReflectionEffect effect, ref IPL.ReflectionEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out, IPL.ReflectionMixer mixer);
        
        /// <summary>
        /// Creates a reflection effect mixer.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings used when creating the reflection effects that will be mixed into
        /// this reflection mixer.</param>
        /// <param name="mixer">[out] The created reflection mixer.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionMixerCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ReflectionMixerCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.ReflectionEffectSettings effectSettings, out IPL.ReflectionMixer mixer);
        
        /// <summary>
        /// Retains an additional reference to a reflection mixer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to retain a reference to.</param>
        /// <returns>The additional reference to the reflection mixer.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionMixerRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.ReflectionMixer ReflectionMixerRetain(IPL.ReflectionMixer mixer);
        
        /// <summary>
        /// Releases a reference to a reflection mixer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplReflectionMixerRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionMixerRelease(ref IPL.ReflectionMixer mixer);
        
        /// <summary>
        /// Resets the internal processing state of a reflection mixer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to reset.</param>
        [DllImport(Library, EntryPoint = "iplReflectionMixerReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionMixerReset(IPL.ReflectionMixer mixer);
        
        /// <summary>
        /// Retrieves the contents of a reflection mixer and places it into an audio buffer.
        /// </summary>
        /// <param name="mixer">The reflection mixer to retrieve audio from.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as the impulse response
        /// specified when creating the mixer.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        [DllImport(Library, EntryPoint = "iplReflectionMixerApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState ReflectionMixerApply(IPL.ReflectionMixer mixer, ref IPL.ReflectionEffectParams @params, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates a path effect.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="audioSettings">Global audio processing settings.</param>
        /// <param name="effectSettings">The settings to use when creating the path effect.</param>
        /// <param name="effect">[out] The created path effect.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplPathEffectCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error PathEffectCreate(IPL.Context context, in IPL.AudioSettings audioSettings, in IPL.PathEffectSettings effectSettings, out IPL.PathEffect effect);
        
        /// <summary>
        /// Retains an additional reference to a path effect.
        /// </summary>
        /// <param name="effect">The path effect to retain a reference to.</param>
        /// <returns>The additional reference to the path effect.</returns>
        [DllImport(Library, EntryPoint = "iplPathEffectRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.PathEffect PathEffectRetain(IPL.PathEffect effect);
        
        /// <summary>
        /// Releases a reference to a path effect.
        /// </summary>
        /// <param name="effect">The path effect to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplPathEffectRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathEffectRelease(ref IPL.PathEffect effect);
        
        /// <summary>
        /// Resets the internal processing state of a path effect.
        /// </summary>
        /// <param name="effect">The path effect to reset.</param>
        [DllImport(Library, EntryPoint = "iplPathEffectReset", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathEffectReset(IPL.PathEffect effect);
        
        /// <summary>
        /// Applies a path effect to an audio buffer.
        /// </summary>
        /// <param name="effect">The path effect to apply.</param>
        /// <param name="params">Parameters for applying the effect.</param>
        /// <param name="in">The input audio buffer. Must have 1 channel.</param>
        /// <param name="out">The output audio buffer. Must have as many channels as needed for the
        /// Ambisonics order specified when creating the effect.</param>
        /// <returns>@c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or
        /// @c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise.</returns>
        /// <remarks>
        /// This effect CANNOT be applied in-place.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplPathEffectApply", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.AudioEffectState PathEffectApply(IPL.PathEffect effect, ref IPL.PathEffectParams @params, ref IPL.AudioBuffer @in, ref IPL.AudioBuffer @out);
        
        /// <summary>
        /// Creates an empty probe array.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="probeArray">[out] The created probe array.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplProbeArrayCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ProbeArrayCreate(IPL.Context context, out IPL.ProbeArray probeArray);
        
        /// <summary>
        /// Retains an additional reference to a probe array.
        /// </summary>
        /// <param name="probeArray">The probe array to retain a reference to.</param>
        /// <returns>The additional reference to the probe array.</returns>
        [DllImport(Library, EntryPoint = "iplProbeArrayRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.ProbeArray ProbeArrayRetain(IPL.ProbeArray probeArray);
        
        /// <summary>
        /// Releases a reference to a probe array.
        /// </summary>
        /// <param name="probeArray">The probe array to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplProbeArrayRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeArrayRelease(ref IPL.ProbeArray probeArray);
        
        /// <summary>
        /// Generates probes and adds them to a probe array.
        /// </summary>
        /// <param name="scene">The scene in which to generate probes.</param>
        /// <param name="params">Parameters to use for generating probes.</param>
        /// <param name="probeArray">The array into which to add the generated probes.</param>
        [DllImport(Library, EntryPoint = "iplProbeArrayGenerateProbes", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeArrayGenerateProbes(IPL.ProbeArray probeArray, IPL.Scene scene, ref IPL.ProbeGenerationParams @params);
        
        /// <param name="probeArray">The probe array.</param>
        /// <returns>The number of probes in a probe array.</returns>
        [DllImport(Library, EntryPoint = "iplProbeArrayGetNumProbes", CallingConvention = CallingConvention.Cdecl)]
        public static extern int ProbeArrayGetNumProbes(IPL.ProbeArray probeArray);
        
        /// <param name="probeArray">The probe array.</param>
        /// <param name="index">Index of the probe within the array.</param>
        /// <returns>The probe at a given index in a probe array.</returns>
        [DllImport(Library, EntryPoint = "iplProbeArrayGetProbe", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Sphere ProbeArrayGetProbe(IPL.ProbeArray probeArray, int index);
        
        /// <summary>
        /// Creates an empty probe batch.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="probeBatch">[out] The created probe batch.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ProbeBatchCreate(IPL.Context context, out IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Retains an additional reference to a probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to retain a reference to.</param>
        /// <returns>The additional reference to the probe batch.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.ProbeBatch ProbeBatchRetain(IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Releases a reference to a probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchRelease(ref IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Loads a probe batch from a serialized object. Typically, the serialized object will be created from a byte array
        /// loaded from disk or over the network.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="serializedObject">The serialized object from which to load the probe batch.</param>
        /// <param name="probeBatch">[out] The created probe batch.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchLoad", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error ProbeBatchLoad(IPL.Context context, IPL.SerializedObject serializedObject, out IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Saves a probe batch to a serialized object. Typically, the serialized object will then be saved to disk.
        /// </summary>
        /// <param name="serializedObject">The serialized object into which to save the probe batch.</param>
        /// <param name="probeBatch">The probe batch to save.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchSave", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchSave(IPL.ProbeBatch probeBatch, IPL.SerializedObject serializedObject);
        
        /// <param name="probeBatch">The probe batch.</param>
        /// <returns>The number of probes in a probe batch.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchGetNumProbes", CallingConvention = CallingConvention.Cdecl)]
        public static extern int ProbeBatchGetNumProbes(IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Adds a probe to a batch. The new probe will be added as the last probe in the batch.
        /// </summary>
        /// <param name="probe">The probe to add.</param>
        /// <param name="probeBatch">The probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchAddProbe", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchAddProbe(IPL.ProbeBatch probeBatch, IPL.Sphere probe);
        
        /// <summary>
        /// Adds every probe in an array to a batch. The new probes will be added, in order, at the end of the batch.
        /// </summary>
        /// <param name="probeArray">The probe array containing the probes to add.</param>
        /// <param name="probeBatch">The probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchAddProbeArray", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchAddProbeArray(IPL.ProbeBatch probeBatch, IPL.ProbeArray probeArray);
        
        /// <summary>
        /// Removes a probe from a batch.
        /// </summary>
        /// <param name="index">Index of the probe to remove.</param>
        /// <param name="probeBatch">The probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchRemoveProbe", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchRemoveProbe(IPL.ProbeBatch probeBatch, int index);
        
        /// <summary>
        /// Commits all changes made to a probe batch since this function was last called (or since the probe batch was
        /// first created, if this function was never called). This function must be called after adding, removing, or
        /// updating any probes in the batch, for the changes to take effect.
        /// </summary>
        /// <param name="probeBatch">The probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchCommit", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchCommit(IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Deletes a specific layer of data from a probe batch.
        /// </summary>
        /// <param name="identifier">The identifier of the baked data layer to delete.</param>
        /// <param name="probeBatch">The probe batch.</param>
        [DllImport(Library, EntryPoint = "iplProbeBatchRemoveData", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ProbeBatchRemoveData(IPL.ProbeBatch probeBatch, in IPL.BakedDataIdentifier identifier);
        
        /// <param name="probeBatch">The probe batch.</param>
        /// <param name="identifier">The identifier of the baked data layer.</param>
        /// <returns>The size (in bytes) of a specific baked data layer in a probe batch.</returns>
        [DllImport(Library, EntryPoint = "iplProbeBatchGetDataSize", CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong ProbeBatchGetDataSize(IPL.ProbeBatch probeBatch, in IPL.BakedDataIdentifier identifier);
        
        /// <summary>
        /// Bakes a single layer of reflections data in a probe batch.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="params">Parameters to use for baking reflections data.</param>
        /// <param name="progressCallback">(Optional) This function will be called by Steam Audio to notify your application
        /// as the bake progresses. Use this to display a progress bar or some other indicator
        /// that the bake is running.</param>
        /// <param name="userData">(Optional) Pointer to arbitrary data that will be sent to the progress callback
        /// when Steam Audio calls it.</param>
        /// <remarks>
        /// Only one bake can be in progress at any point in time.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplReflectionsBakerBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionsBakerBake(IPL.Context context, ref IPL.ReflectionsBakeParams @params, IPL.ProgressCallback progressCallback, IntPtr userData);
        
        /// <summary>
        /// Cancels any running bakes of reflections data.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        [DllImport(Library, EntryPoint = "iplReflectionsBakerCancelBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReflectionsBakerCancelBake(IPL.Context context);
        
        /// <summary>
        /// Bakes a single layer of pathing data in a probe batch.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="params">Parameters to use for baking pathing data.</param>
        /// <param name="progressCallback">(Optional) This function will be called by Steam Audio to notify your application
        /// as the bake progresses. Use this to display a progress bar or some other indicator
        /// that the bake is running.</param>
        /// <param name="userData">(Optional) Pointer to arbitrary data that will be sent to the progress callback
        /// when Steam Audio calls it.</param>
        /// <remarks>
        /// Only one bake can be in progress at any point in time.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplPathBakerBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathBakerBake(IPL.Context context, ref IPL.PathBakeParams @params, IPL.ProgressCallback progressCallback, IntPtr userData);
        
        /// <summary>
        /// Cancels any running bakes of pathing data.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        [DllImport(Library, EntryPoint = "iplPathBakerCancelBake", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PathBakerCancelBake(IPL.Context context);
        
        /// <summary>
        /// Creates a simulator.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="settings">The settings to use when creating the simulator.</param>
        /// <param name="simulator">[out] The created simulator.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSimulatorCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SimulatorCreate(IPL.Context context, in IPL.SimulationSettings settings, out IPL.Simulator simulator);
        
        /// <summary>
        /// Retains an additional reference to a simulator.
        /// </summary>
        /// <param name="simulator">The simulator to retain a reference to.</param>
        /// <returns>The additional reference to the simulator.</returns>
        [DllImport(Library, EntryPoint = "iplSimulatorRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Simulator SimulatorRetain(IPL.Simulator simulator);
        
        /// <summary>
        /// Releases a reference to a simulator.
        /// </summary>
        /// <param name="simulator">The simulator to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSimulatorRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRelease(ref IPL.Simulator simulator);
        
        /// <summary>
        /// Specifies the scene within which all subsequent simulations should be run.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <param name="scene">The scene to use for simulations.</param>
        /// <remarks>
        /// Call @c iplSimulatorCommit after calling this function for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorSetScene", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorSetScene(IPL.Simulator simulator, IPL.Scene scene);
        
        /// <summary>
        /// Adds a probe batch for use in subsequent simulations. Sources that require baked data can then use the
        /// data contained in the specified probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to add.</param>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// Call @c iplSimulatorCommit after calling this function for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorAddProbeBatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorAddProbeBatch(IPL.Simulator simulator, IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Removed a probe batch from use in subsequent simulations. Sources that require baked data will then stop using the
        /// data contained in the specified probe batch.
        /// </summary>
        /// <param name="probeBatch">The probe batch to remove.</param>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// Call @c iplSimulatorCommit after calling this function for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRemoveProbeBatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRemoveProbeBatch(IPL.Simulator simulator, IPL.ProbeBatch probeBatch);
        
        /// <summary>
        /// Specifies simulation parameters that are not associated with any particular source.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <param name="flags">The types of simulation for which to specify shared inputs. If, for example, direct
        /// and reflections simulations are being run on separate threads, you can call this
        /// function on the direct simulation thread with @c IPL_SIMULATIONFLAGS_DIRECT, and on the
        /// reflections simulation thread with @c IPL_SIMULATIONFLAGS_REFLECTIONS, without requiring
        /// any synchronization between the calls.</param>
        /// <param name="sharedInputs">The shared input parameters to set.</param>
        [DllImport(Library, EntryPoint = "iplSimulatorSetSharedInputs", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorSetSharedInputs(IPL.Simulator simulator, IPL.SimulationFlags flags, in IPL.SimulationSharedInputs sharedInputs);
        
        /// <summary>
        /// Commits changes to the scene or probe batches used for simulation.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// Call this function after calling @c iplSimulatorSetScene, @c iplSimulatorAddProbeBatch, or 
        /// @c iplSimulatorRemoveProbeBatch for the changes to take effect.This function cannot be called while any simulation is running.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorCommit", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorCommit(IPL.Simulator simulator);
        
        /// <summary>
        /// Runs a direct simulation for all sources added to the simulator. This may include distance attenuation,
        /// air absorption, directivity, occlusion, and transmission.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// This function should not be called from the audio processing thread if occlusion and/or transmission
        /// are enabled.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRunDirect", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRunDirect(IPL.Simulator simulator);
        
        /// <summary>
        /// Runs a reflections simulation for all sources added to the simulator.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// This function can be CPU intensive, and should be called from a separate thread in order to not
        /// block either the audio processing thread or the game's main update thread.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRunReflections", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRunReflections(IPL.Simulator simulator);
        
        /// <summary>
        /// Runs a pathing simulation for all sources added to the simulator.
        /// </summary>
        /// <param name="simulator">The simulator being used.</param>
        /// <remarks>
        /// This function can be CPU intensive, and should be called from a separate thread in order to not
        /// block either the audio processing thread or the game's main update thread.
        /// </remarks>
        [DllImport(Library, EntryPoint = "iplSimulatorRunPathing", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SimulatorRunPathing(IPL.Simulator simulator);
        
        /// <summary>
        /// Creates a simulation source.
        /// </summary>
        /// <param name="simulator">The simulator with which this source will be used.</param>
        /// <param name="settings">The settings to use for creating the source.</param>
        /// <param name="source">[out] The created source.</param>
        /// <returns>Status code indicating whether or not the operation succeeded.</returns>
        [DllImport(Library, EntryPoint = "iplSourceCreate", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Error SourceCreate(IPL.Simulator simulator, in IPL.SourceSettings settings, out IPL.Source source);
        
        /// <summary>
        /// Retains an additional reference to a source.
        /// </summary>
        /// <param name="source">The source to retain a reference to.</param>
        /// <returns>The additional reference to the source.</returns>
        [DllImport(Library, EntryPoint = "iplSourceRetain", CallingConvention = CallingConvention.Cdecl)]
        public static extern IPL.Source SourceRetain(IPL.Source source);
        
        /// <summary>
        /// Releases a reference to a source.
        /// </summary>
        /// <param name="source">The source to release a reference to.</param>
        [DllImport(Library, EntryPoint = "iplSourceRelease", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceRelease(ref IPL.Source source);
        
        /// <summary>
        /// Adds a source to the set of sources processed by a simulator in subsequent simulations.
        /// </summary>
        /// <param name="source">The source to add.</param>
        /// <param name="simulator">The simulator being used.</param>
        [DllImport(Library, EntryPoint = "iplSourceAdd", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceAdd(IPL.Source source, IPL.Simulator simulator);
        
        /// <summary>
        /// Removes a source from the set of sources processed by a simulator in subsequent simulations.
        /// </summary>
        /// <param name="source">The source to remove.</param>
        /// <param name="simulator">The simulator being used.</param>
        [DllImport(Library, EntryPoint = "iplSourceRemove", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceRemove(IPL.Source source, IPL.Simulator simulator);
        
        /// <summary>
        /// Specifies simulation parameters for a source.
        /// </summary>
        /// <param name="source">The source to specify parameters for.</param>
        /// <param name="flags">The types of simulation for which to specify inputs. If, for example, direct
        /// and reflections simulations are being run on separate threads, you can call this
        /// function on the direct simulation thread with @c IPL_SIMULATIONFLAGS_DIRECT, and on the
        /// reflections simulation thread with @c IPL_SIMULATIONFLAGS_REFLECTIONS, without requiring
        /// any synchronization between the calls.</param>
        /// <param name="inputs">The input parameters to set.</param>
        [DllImport(Library, EntryPoint = "iplSourceSetInputs", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceSetInputs(IPL.Source source, IPL.SimulationFlags flags, in IPL.SimulationInputs inputs);
        
        /// <summary>
        /// Retrieves simulation results for a source.
        /// </summary>
        /// <param name="source">The source to retrieve results for.</param>
        /// <param name="flags">The types of simulation for which to retrieve results.</param>
        /// <param name="outputs">[out] The simulation results.</param>
        [DllImport(Library, EntryPoint = "iplSourceGetOutputs", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SourceGetOutputs(IPL.Source source, IPL.SimulationFlags flags, out IPL.SimulationOutputs outputs);
        
        /// <summary>
        /// Calculates the distance attenuation between a source and a listener.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="source">The position of the source.</param>
        /// <param name="listener">The position of the listener.</param>
        /// <param name="model">The distance attenuation model to use.</param>
        /// <returns>The distance attenuation to apply, between @c 0 and @c 1.</returns>
        [DllImport(Library, EntryPoint = "iplDistanceAttenuationCalculate", CallingConvention = CallingConvention.Cdecl)]
        public static extern float DistanceAttenuationCalculate(IPL.Context context, IPL.Vector3 source, IPL.Vector3 listener, in IPL.DistanceAttenuationModel model);
        
        /// <summary>
        /// Calculates the air absorption coefficients between a source and a listener.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="source">The position of the source.</param>
        /// <param name="listener">The position of the listener.</param>
        /// <param name="model">The air absorption model to use.</param>
        /// <param name="airAbsorption">[out] The 3-band air absorption coefficients, each between @c 0 and @c 1.</param>
        [DllImport(Library, EntryPoint = "iplAirAbsorptionCalculate", CallingConvention = CallingConvention.Cdecl)]
        public static extern void AirAbsorptionCalculate(IPL.Context context, IPL.Vector3 source, IPL.Vector3 listener, in IPL.AirAbsorptionModel model, out float airAbsorption);
        
        /// <summary>
        /// Calculates the attenuation of a source due to its directivity pattern and orientation relative to a listener.
        /// </summary>
        /// <param name="context">The context used to initialize Steam Audio.</param>
        /// <param name="source">The position and orientation of the source.</param>
        /// <param name="listener">The position of the listener.</param>
        /// <param name="model">The directivity pattern to use.</param>
        /// <returns>The directivity value to apply, between @c 0 and @c 1.</returns>
        [DllImport(Library, EntryPoint = "iplDirectivityCalculate", CallingConvention = CallingConvention.Cdecl)]
        public static extern float DirectivityCalculate(IPL.Context context, IPL.CoordinateSpace3 source, IPL.Vector3 listener, in IPL.Directivity model);
        
        public const uint VersionMajor = 4;
        
        public const uint VersionMinor = 0;
        
        public const uint VersionPatch = 3;
        
        public const uint Version = (((uint)(VersionMajor)<<16)|((uint)(VersionMinor)<<8)|((uint)(VersionPatch)));
    }
}
